<!doctype html>
<html>
<head>

<script type="text/javascript">
(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);
</script>

<script type="text/javascript">
(function() {


  $(function() {
    var params, progress_hook;
    params = {
      N: 1 << 17,
      c1: 1 << 16,
      p: 1,
      r: 8,
      dkLen: 256 / 8
    };
    progress_hook = function(o) {
      return $("#progress").html(JSON.stringify(o));
    };
    return $('#btn-submit').on('click', function() {
      var d, k, v;
      $('.output-form').show();
      d = {};
      for (k in params) {
        v = params[k];
        d[k] = v;
      }
      d.salt = $('#salt').val();
      d.key = $('#passphrase').val();
      d.progress_hook = progress_hook;
      return warpwallet.scrypt(d, function(words) {
        var out;
        out = warpwallet.generate(words.to_buffer());
        $('#public-address').val(out["public"]);
        return $('#private-key').val(out["private"]);
      });
    });
  });

}).call(this);

</script>

<script type="text/javascript">
!function(e){"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):"undefined"!=typeof window?window.warpwallet=e():"undefined"!=typeof global?global.warpwallet=e():"undefined"!=typeof self&&(self.warpwallet=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.binarySlice === 'function'
  ;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":1}],3:[function(require,module,exports){
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"q9TxCC":[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":1,"assert":6,"base64-js":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],4:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],5:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":5,"util":7}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":5}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],5:[function(require,module,exports){
var process=require("__browserify_process");// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var generator,
    __slice = [].slice;



  exports.generator = generator = function(intern, compiletime, runtime) {
    var C, Deferrals, Rendezvous, exceptionHandler, findDeferral, stackWalk;
    compiletime.transform = function(x, options) {
      return x.icedTransform(options);
    };
    compiletime["const"] = C = {
      k: "__iced_k",
      k_noop: "__iced_k_noop",
      param: "__iced_p_",
      ns: "iced",
      runtime: "runtime",
      Deferrals: "Deferrals",
      deferrals: "__iced_deferrals",
      fulfill: "_fulfill",
      b_while: "_break",
      t_while: "_while",
      c_while: "_continue",
      n_while: "_next",
      n_arg: "__iced_next_arg",
      context: "context",
      defer_method: "defer",
      slot: "__slot",
      assign_fn: "assign_fn",
      autocb: "autocb",
      retslot: "ret",
      trace: "__iced_trace",
      passed_deferral: "__iced_passed_deferral",
      findDeferral: "findDeferral",
      lineno: "lineno",
      parent: "parent",
      filename: "filename",
      funcname: "funcname",
      catchExceptions: 'catchExceptions',
      runtime_modes: ["node", "inline", "window", "none", "browserify"],
      trampoline: "trampoline"
    };
    intern.makeDeferReturn = function(obj, defer_args, id, trace_template, multi) {
      var k, ret, trace, v;
      trace = {};
      for (k in trace_template) {
        v = trace_template[k];
        trace[k] = v;
      }
      trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;
      ret = function() {
        var inner_args, o, _ref;
        inner_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (defer_args != null) {
          if ((_ref = defer_args.assign_fn) != null) {
            _ref.apply(null, inner_args);
          }
        }
        if (obj) {
          o = obj;
          if (!multi) {
            obj = null;
          }
          return o._fulfill(id, trace);
        } else {
          return intern._warn("overused deferral at " + (intern._trace_to_string(trace)));
        }
      };
      ret[C.trace] = trace;
      return ret;
    };
    intern.__c = 0;
    intern.tickCounter = function(mod) {
      intern.__c++;
      if ((intern.__c % mod) === 0) {
        intern.__c = 0;
        return true;
      } else {
        return false;
      }
    };
    intern.__active_trace = null;
    intern._trace_to_string = function(tr) {
      var fn;
      fn = tr[C.funcname] || "<anonymous>";
      return "" + fn + " (" + tr[C.filename] + ":" + (tr[C.lineno] + 1) + ")";
    };
    intern._warn = function(m) {
      return typeof console !== "undefined" && console !== null ? console.log("ICED warning: " + m) : void 0;
    };
    runtime.trampoline = function(fn) {
      if (!intern.tickCounter(500)) {
        return fn();
      } else if (typeof process !== "undefined" && process !== null) {
        return process.nextTick(fn);
      } else {
        return setTimeout(fn);
      }
    };
    runtime.Deferrals = Deferrals = (function() {
      function Deferrals(k, trace) {
        this.trace = trace;
        this.continuation = k;
        this.count = 1;
        this.ret = null;
      }

      Deferrals.prototype._call = function(trace) {
        var c;
        if (this.continuation) {
          intern.__active_trace = trace;
          c = this.continuation;
          this.continuation = null;
          return c(this.ret);
        } else {
          return intern._warn("Entered dead await at " + (intern._trace_to_string(trace)));
        }
      };

      Deferrals.prototype._fulfill = function(id, trace) {
        var _this = this;
        if (--this.count > 0) {

        } else {
          return runtime.trampoline((function() {
            return _this._call(trace);
          }));
        }
      };

      Deferrals.prototype.defer = function(args) {
        var self;
        this.count++;
        self = this;
        return intern.makeDeferReturn(self, args, null, this.trace);
      };

      Deferrals.prototype._defer = function(args) {
        return this["defer"](args);
      };

      return Deferrals;

    })();
    runtime.findDeferral = findDeferral = function(args) {
      var a, _i, _len;
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        a = args[_i];
        if (a != null ? a[C.trace] : void 0) {
          return a;
        }
      }
      return null;
    };
    runtime.Rendezvous = Rendezvous = (function() {
      var RvId;

      function Rendezvous() {
        this.completed = [];
        this.waiters = [];
        this.defer_id = 0;
      }

      RvId = (function() {
        function RvId(rv, id, multi) {
          this.rv = rv;
          this.id = id;
          this.multi = multi;
        }

        RvId.prototype.defer = function(defer_args) {
          return this.rv._deferWithId(this.id, defer_args, this.multi);
        };

        return RvId;

      })();

      Rendezvous.prototype.wait = function(cb) {
        var x;
        if (this.completed.length) {
          x = this.completed.shift();
          return cb(x);
        } else {
          return this.waiters.push(cb);
        }
      };

      Rendezvous.prototype.defer = function(defer_args) {
        var id;
        id = this.defer_id++;
        return this.deferWithId(id, defer_args);
      };

      Rendezvous.prototype.id = function(i, multi) {
        if (multi == null) {
          multi = false;
        }
        return new RvId(this, i, multi);
      };

      Rendezvous.prototype._fulfill = function(id, trace) {
        var cb;
        if (this.waiters.length) {
          cb = this.waiters.shift();
          return cb(id);
        } else {
          return this.completed.push(id);
        }
      };

      Rendezvous.prototype._deferWithId = function(id, defer_args, multi) {
        this.count++;
        return intern.makeDeferReturn(this, defer_args, id, {}, multi);
      };

      return Rendezvous;

    })();
    runtime.stackWalk = stackWalk = function(cb) {
      var line, ret, tr, _ref;
      ret = [];
      tr = cb ? cb[C.trace] : intern.__active_trace;
      while (tr) {
        line = "   at " + (intern._trace_to_string(tr));
        ret.push(line);
        tr = tr != null ? (_ref = tr[C.parent]) != null ? _ref[C.trace] : void 0 : void 0;
      }
      return ret;
    };
    runtime.exceptionHandler = exceptionHandler = function(err, logger) {
      var stack;
      if (!logger) {
        logger = console.log;
      }
      logger(err.stack);
      stack = stackWalk();
      if (stack.length) {
        logger("Iced callback trace:");
        return logger(stack.join("\n"));
      }
    };
    return runtime.catchExceptions = function(logger) {
      return typeof process !== "undefined" && process !== null ? process.on('uncaughtException', function(err) {
        exceptionHandler(err, logger);
        return process.exit(1);
      }) : void 0;
    };
  };

  exports.runtime = {};

  generator(this, exports, exports.runtime);

}).call(this);

},{"__browserify_process":4}],6:[function(require,module,exports){

var lib = require('./lib/lib.js');

// This is actually the one function that we expose.  The rest
// isn't ready to use, yet.
exports.generate = function(buffer) {
    var a = new Array(buffer.length);
    var i;
    for (i = 0; i < buffer.length; i++) {
        a[i] = buffer.readUInt8(i);
    }
    var key = new lib.Bitcoin.ECKey(a);
    var ret = {
        "public"  : key.getBitcoinAddress(),
        "private" : key.getBitcoinWalletImportFormat()
    };
    return ret;
};

},{"./lib/lib.js":7}],7:[function(require,module,exports){

var Crypto = exports.Crypto = {};
var Bitcoin = exports.Bitcoin = {};
// Array.prototype.map function is in the public domain.
// Production steps of ECMA-262, Edition 5, 15.4.4.19  
// Reference: http://es5.github.com/#x15.4.4.19  
if (!Array.prototype.map) {
	Array.prototype.map = function (callback, thisArg) {
		var T, A, k;
		if (this == null) {
			throw new TypeError(" this is null or not defined");
		}
		// 1. Let O be the result of calling ToObject passing the |this| value as the argument.  
		var O = Object(this);
		// 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".  
		// 3. Let len be ToUint32(lenValue).  
		var len = O.length >>> 0;
		// 4. If IsCallable(callback) is false, throw a TypeError exception.  
		// See: http://es5.github.com/#x9.11  
		if ({}.toString.call(callback) != "[object Function]") {
			throw new TypeError(callback + " is not a function");
		}
		// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.  
		if (thisArg) {
			T = thisArg;
		}
		// 6. Let A be a new array created as if by the expression new Array(len) where Array is  
		// the standard built-in constructor with that name and len is the value of len.  
		A = new Array(len);
		// 7. Let k be 0  
		k = 0;
		// 8. Repeat, while k < len  
		while (k < len) {
			var kValue, mappedValue;
			// a. Let Pk be ToString(k).  
			//   This is implicit for LHS operands of the in operator  
			// b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.  
			//   This step can be combined with c  
			// c. If kPresent is true, then  
			if (k in O) {
				// i. Let kValue be the result of calling the Get internal method of O with argument Pk.  
				kValue = O[k];
				// ii. Let mappedValue be the result of calling the Call internal method of callback  
				// with T as the this value and argument list containing kValue, k, and O.  
				mappedValue = callback.call(T, kValue, k, O);
				// iii. Call the DefineOwnProperty internal method of A with arguments  
				// Pk, Property Descriptor {Value: mappedValue, Writable: true, Enumerable: true, Configurable: true},  
				// and false.  
				// In browsers that support Object.defineProperty, use the following:  
				// Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });  
				// For best browser support, use the following:  
				A[k] = mappedValue;
			}
			// d. Increase k by 1.  
			k++;
		}
		// 9. return A  
		return A;
	};
}/*!
* Basic JavaScript BN library - subset useful for RSA encryption. v1.3
* 
* Copyright (c) 2005  Tom Wu
* All Rights Reserved.
* BSD License
* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
*
* Copyright Stephan Thomas
* Copyright bitaddress.org
*/


(function (x) {

	// (public) Constructor function of Global BigInteger object
	var BigInteger = x.BigInteger = function BigInteger(a, b, c) {
		if (a != null)
			if ("number" == typeof a) this.fromNumber(a, b, c);
			else if (b == null && "string" != typeof a) this.fromString(a, 256);
			else this.fromString(a, b);
	};

	// Bits per digit
	var dbits;

	// JavaScript engine analysis
	var canary = 0xdeadbeefcafe;
	var j_lm = ((canary & 0xffffff) == 0xefcafe);

	// return new, unset BigInteger
	function nbi() { return new BigInteger(null); }

	// am: Compute w_j += (x*this_i), propagate carries,
	// c is initial carry, returns final carry.
	// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
	// We need to select the fastest one that works in this environment.

	// am1: use a single mult and divide to get the high bits,
	// max digit bits should be 26 because
	// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
	function am1(i, x, w, j, c, n) {
		while (--n >= 0) {
			var v = x * this[i++] + w[j] + c;
			c = Math.floor(v / 0x4000000);
			w[j++] = v & 0x3ffffff;
		}
		return c;
	}
	// am2 avoids a big mult-and-extract completely.
	// Max digit bits should be <= 30 because we do bitwise ops
	// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
	function am2(i, x, w, j, c, n) {
		var xl = x & 0x7fff, xh = x >> 15;
		while (--n >= 0) {
			var l = this[i] & 0x7fff;
			var h = this[i++] >> 15;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
			c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
			w[j++] = l & 0x3fffffff;
		}
		return c;
	}
	// Alternately, set max digit bits to 28 since some
	// browsers slow down when dealing with 32-bit numbers.
	function am3(i, x, w, j, c, n) {
		var xl = x & 0x3fff, xh = x >> 14;
		while (--n >= 0) {
			var l = this[i] & 0x3fff;
			var h = this[i++] >> 14;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
			c = (l >> 28) + (m >> 14) + xh * h;
			w[j++] = l & 0xfffffff;
		}
		return c;
	}

	// Hardcode this for modern browsers
	BigInteger.prototype.am = am3;
	dbits = 28;

	BigInteger.prototype.DB = dbits;
	BigInteger.prototype.DM = ((1 << dbits) - 1);
	BigInteger.prototype.DV = (1 << dbits);

	var BI_FP = 52;
	BigInteger.prototype.FV = Math.pow(2, BI_FP);
	BigInteger.prototype.F1 = BI_FP - dbits;
	BigInteger.prototype.F2 = 2 * dbits - BI_FP;

	// Digit conversions
	var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	var BI_RC = new Array();
	var rr, vv;
	rr = "0".charCodeAt(0);
	for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	rr = "a".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	rr = "A".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

	function int2char(n) { return BI_RM.charAt(n); }
	function intAt(s, i) {
		var c = BI_RC[s.charCodeAt(i)];
		return (c == null) ? -1 : c;
	}



	// return bigint initialized to value
	function nbv(i) { var r = nbi(); r.fromInt(i); return r; }


	// returns bit length of the integer x
	function nbits(x) {
		var r = 1, t;
		if ((t = x >>> 16) != 0) { x = t; r += 16; }
		if ((t = x >> 8) != 0) { x = t; r += 8; }
		if ((t = x >> 4) != 0) { x = t; r += 4; }
		if ((t = x >> 2) != 0) { x = t; r += 2; }
		if ((t = x >> 1) != 0) { x = t; r += 1; }
		return r;
	}







	// (protected) copy this to r
	BigInteger.prototype.copyTo = function (r) {
		for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
		r.t = this.t;
		r.s = this.s;
	};


	// (protected) set from integer value x, -DV <= x < DV
	BigInteger.prototype.fromInt = function (x) {
		this.t = 1;
		this.s = (x < 0) ? -1 : 0;
		if (x > 0) this[0] = x;
		else if (x < -1) this[0] = x + DV;
		else this.t = 0;
	};

	// (protected) set from string and radix
	BigInteger.prototype.fromString = function (s, b) {
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 256) k = 8; // byte array
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else { this.fromRadix(s, b); return; }
		this.t = 0;
		this.s = 0;
		var i = s.length, mi = false, sh = 0;
		while (--i >= 0) {
			var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-") mi = true;
				continue;
			}
			mi = false;
			if (sh == 0)
				this[this.t++] = x;
			else if (sh + k > this.DB) {
				this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
				this[this.t++] = (x >> (this.DB - sh));
			}
			else
				this[this.t - 1] |= x << sh;
			sh += k;
			if (sh >= this.DB) sh -= this.DB;
		}
		if (k == 8 && (s[0] & 0x80) != 0) {
			this.s = -1;
			if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
		}
		this.clamp();
		if (mi) BigInteger.ZERO.subTo(this, this);
	};


	// (protected) clamp off excess high words
	BigInteger.prototype.clamp = function () {
		var c = this.s & this.DM;
		while (this.t > 0 && this[this.t - 1] == c) --this.t;
	};

	// (protected) r = this << n*DB
	BigInteger.prototype.dlShiftTo = function (n, r) {
		var i;
		for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
		for (i = n - 1; i >= 0; --i) r[i] = 0;
		r.t = this.t + n;
		r.s = this.s;
	};

	// (protected) r = this >> n*DB
	BigInteger.prototype.drShiftTo = function (n, r) {
		for (var i = n; i < this.t; ++i) r[i - n] = this[i];
		r.t = Math.max(this.t - n, 0);
		r.s = this.s;
	};


	// (protected) r = this << n
	BigInteger.prototype.lShiftTo = function (n, r) {
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << cbs) - 1;
		var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;
		for (i = this.t - 1; i >= 0; --i) {
			r[i + ds + 1] = (this[i] >> cbs) | c;
			c = (this[i] & bm) << bs;
		}
		for (i = ds - 1; i >= 0; --i) r[i] = 0;
		r[ds] = c;
		r.t = this.t + ds + 1;
		r.s = this.s;
		r.clamp();
	};


	// (protected) r = this >> n
	BigInteger.prototype.rShiftTo = function (n, r) {
		r.s = this.s;
		var ds = Math.floor(n / this.DB);
		if (ds >= this.t) { r.t = 0; return; }
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << bs) - 1;
		r[0] = this[ds] >> bs;
		for (var i = ds + 1; i < this.t; ++i) {
			r[i - ds - 1] |= (this[i] & bm) << cbs;
			r[i - ds] = this[i] >> bs;
		}
		if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
		r.t = this.t - ds;
		r.clamp();
	};


	// (protected) r = this - a
	BigInteger.prototype.subTo = function (a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this[i] - a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c -= a.s;
			while (i < this.t) {
				c += this[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		}
		else {
			c += this.s;
			while (i < a.t) {
				c -= a[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c -= a.s;
		}
		r.s = (c < 0) ? -1 : 0;
		if (c < -1) r[i++] = this.DV + c;
		else if (c > 0) r[i++] = c;
		r.t = i;
		r.clamp();
	};


	// (protected) r = this * a, r != this,a (HAC 14.12)
	// "this" should be the larger one if appropriate.
	BigInteger.prototype.multiplyTo = function (a, r) {
		var x = this.abs(), y = a.abs();
		var i = x.t;
		r.t = i + y.t;
		while (--i >= 0) r[i] = 0;
		for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
		r.s = 0;
		r.clamp();
		if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
	};


	// (protected) r = this^2, r != this (HAC 14.16)
	BigInteger.prototype.squareTo = function (r) {
		var x = this.abs();
		var i = r.t = 2 * x.t;
		while (--i >= 0) r[i] = 0;
		for (i = 0; i < x.t - 1; ++i) {
			var c = x.am(i, x[i], r, 2 * i, 0, 1);
			if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
				r[i + x.t] -= x.DV;
				r[i + x.t + 1] = 1;
			}
		}
		if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
		r.s = 0;
		r.clamp();
	};



	// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
	// r != q, this != m.  q or r may be null.
	BigInteger.prototype.divRemTo = function (m, q, r) {
		var pm = m.abs();
		if (pm.t <= 0) return;
		var pt = this.abs();
		if (pt.t < pm.t) {
			if (q != null) q.fromInt(0);
			if (r != null) this.copyTo(r);
			return;
		}
		if (r == null) r = nbi();
		var y = nbi(), ts = this.s, ms = m.s;
		var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
		if (nsh > 0) { pm.lShiftTo(nsh, y); pt.lShiftTo(nsh, r); }
		else { pm.copyTo(y); pt.copyTo(r); }
		var ys = y.t;
		var y0 = y[ys - 1];
		if (y0 == 0) return;
		var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
		var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
		var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
		y.dlShiftTo(j, t);
		if (r.compareTo(t) >= 0) {
			r[r.t++] = 1;
			r.subTo(t, r);
		}
		BigInteger.ONE.dlShiftTo(ys, t);
		t.subTo(y, y); // "negative" y so we can replace sub with am later
		while (y.t < ys) y[y.t++] = 0;
		while (--j >= 0) {
			// Estimate quotient digit
			var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
			if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {	// Try it out
				y.dlShiftTo(j, t);
				r.subTo(t, r);
				while (r[i] < --qd) r.subTo(t, r);
			}
		}
		if (q != null) {
			r.drShiftTo(ys, q);
			if (ts != ms) BigInteger.ZERO.subTo(q, q);
		}
		r.t = ys;
		r.clamp();
		if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
		if (ts < 0) BigInteger.ZERO.subTo(r, r);
	};


	// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
	// justification:
	//         xy == 1 (mod m)
	//         xy =  1+km
	//   xy(2-xy) = (1+km)(1-km)
	// x[y(2-xy)] = 1-k^2m^2
	// x[y(2-xy)] == 1 (mod m^2)
	// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
	// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
	// JS multiply "overflows" differently from C/C++, so care is needed here.
	BigInteger.prototype.invDigit = function () {
		if (this.t < 1) return 0;
		var x = this[0];
		if ((x & 1) == 0) return 0;
		var y = x & 3; 	// y == 1/x mod 2^2
		y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
		y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
		y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
		// last step - calculate inverse mod DV directly;
		// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
		y = (y * (2 - x * y % this.DV)) % this.DV; 	// y == 1/x mod 2^dbits
		// we really want the negative inverse, and -DV < y < DV
		return (y > 0) ? this.DV - y : -y;
	};


	// (protected) true iff this is even
	BigInteger.prototype.isEven = function () { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0; };


	// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
	BigInteger.prototype.exp = function (e, z) {
		if (e > 0xffffffff || e < 1) return BigInteger.ONE;
		var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
		g.copyTo(r);
		while (--i >= 0) {
			z.sqrTo(r, r2);
			if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
			else { var t = r; r = r2; r2 = t; }
		}
		return z.revert(r);
	};


	// (public) return string representation in given radix
	BigInteger.prototype.toString = function (b) {
		if (this.s < 0) return "-" + this.negate().toString(b);
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else return this.toRadix(b);
		var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
		var p = this.DB - (i * this.DB) % k;
		if (i-- > 0) {
			if (p < this.DB && (d = this[i] >> p) > 0) { m = true; r = int2char(d); }
			while (i >= 0) {
				if (p < k) {
					d = (this[i] & ((1 << p) - 1)) << (k - p);
					d |= this[--i] >> (p += this.DB - k);
				}
				else {
					d = (this[i] >> (p -= k)) & km;
					if (p <= 0) { p += this.DB; --i; }
				}
				if (d > 0) m = true;
				if (m) r += int2char(d);
			}
		}
		return m ? r : "0";
	};


	// (public) -this
	BigInteger.prototype.negate = function () { var r = nbi(); BigInteger.ZERO.subTo(this, r); return r; };

	// (public) |this|
	BigInteger.prototype.abs = function () { return (this.s < 0) ? this.negate() : this; };

	// (public) return + if this > a, - if this < a, 0 if equal
	BigInteger.prototype.compareTo = function (a) {
		var r = this.s - a.s;
		if (r != 0) return r;
		var i = this.t;
		r = i - a.t;
		if (r != 0) return (this.s < 0) ? -r : r;
		while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
		return 0;
	}

	// (public) return the number of bits in "this"
	BigInteger.prototype.bitLength = function () {
		if (this.t <= 0) return 0;
		return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
	};

	// (public) this mod a
	BigInteger.prototype.mod = function (a) {
		var r = nbi();
		this.abs().divRemTo(a, null, r);
		if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
		return r;
	}

	// (public) this^e % m, 0 <= e < 2^32
	BigInteger.prototype.modPowInt = function (e, m) {
		var z;
		if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
		return this.exp(e, z);
	};

	// "constants"
	BigInteger.ZERO = nbv(0);
	BigInteger.ONE = nbv(1);







	// Copyright (c) 2005-2009  Tom Wu
	// All Rights Reserved.
	// See "LICENSE" for details.
	// Extended JavaScript BN functions, required for RSA private ops.
	// Version 1.1: new BigInteger("0", 10) returns "proper" zero
	// Version 1.2: square() API, isProbablePrime fix


	// return index of lowest 1-bit in x, x < 2^31
	function lbit(x) {
		if (x == 0) return -1;
		var r = 0;
		if ((x & 0xffff) == 0) { x >>= 16; r += 16; }
		if ((x & 0xff) == 0) { x >>= 8; r += 8; }
		if ((x & 0xf) == 0) { x >>= 4; r += 4; }
		if ((x & 3) == 0) { x >>= 2; r += 2; }
		if ((x & 1) == 0) ++r;
		return r;
	}

	// return number of 1 bits in x
	function cbit(x) {
		var r = 0;
		while (x != 0) { x &= x - 1; ++r; }
		return r;
	}

	var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];



	// (protected) return x s.t. r^x < DV
	BigInteger.prototype.chunkSize = function (r) { return Math.floor(Math.LN2 * this.DB / Math.log(r)); };

	// (protected) convert to radix string
	BigInteger.prototype.toRadix = function (b) {
		if (b == null) b = 10;
		if (this.signum() == 0 || b < 2 || b > 36) return "0";
		var cs = this.chunkSize(b);
		var a = Math.pow(b, cs);
		var d = nbv(a), y = nbi(), z = nbi(), r = "";
		this.divRemTo(d, y, z);
		while (y.signum() > 0) {
			r = (a + z.intValue()).toString(b).substr(1) + r;
			y.divRemTo(d, y, z);
		}
		return z.intValue().toString(b) + r;
	};

	// (protected) convert from radix string
	BigInteger.prototype.fromRadix = function (s, b) {
		this.fromInt(0);
		if (b == null) b = 10;
		var cs = this.chunkSize(b);
		var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
		for (var i = 0; i < s.length; ++i) {
			var x = intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
				continue;
			}
			w = b * w + x;
			if (++j >= cs) {
				this.dMultiply(d);
				this.dAddOffset(w, 0);
				j = 0;
				w = 0;
			}
		}
		if (j > 0) {
			this.dMultiply(Math.pow(b, j));
			this.dAddOffset(w, 0);
		}
		if (mi) BigInteger.ZERO.subTo(this, this);
	};

	// (protected) alternate constructor
	BigInteger.prototype.fromNumber = function (a, b, c) {
		if ("number" == typeof b) {
			// new BigInteger(int,int,RNG)
			if (a < 2) this.fromInt(1);
			else {
				this.fromNumber(a, c);
				if (!this.testBit(a - 1))	// force MSB set
					this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
				if (this.isEven()) this.dAddOffset(1, 0); // force odd
				while (!this.isProbablePrime(b)) {
					this.dAddOffset(2, 0);
					if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
				}
			}
		}
		else {
			// new BigInteger(int,RNG)
			var x = new Array(), t = a & 7;
			x.length = (a >> 3) + 1;
			b.nextBytes(x);
			if (t > 0) x[0] &= ((1 << t) - 1); else x[0] = 0;
			this.fromString(x, 256);
		}
	};

	// (protected) r = this op a (bitwise)
	BigInteger.prototype.bitwiseTo = function (a, op, r) {
		var i, f, m = Math.min(a.t, this.t);
		for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
		if (a.t < this.t) {
			f = a.s & this.DM;
			for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
			r.t = this.t;
		}
		else {
			f = this.s & this.DM;
			for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
			r.t = a.t;
		}
		r.s = op(this.s, a.s);
		r.clamp();
	};

	// (protected) this op (1<<n)
	BigInteger.prototype.changeBit = function (n, op) {
		var r = BigInteger.ONE.shiftLeft(n);
		this.bitwiseTo(r, op, r);
		return r;
	};

	// (protected) r = this + a
	BigInteger.prototype.addTo = function (a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this[i] + a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c += a.s;
			while (i < this.t) {
				c += this[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		}
		else {
			c += this.s;
			while (i < a.t) {
				c += a[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += a.s;
		}
		r.s = (c < 0) ? -1 : 0;
		if (c > 0) r[i++] = c;
		else if (c < -1) r[i++] = this.DV + c;
		r.t = i;
		r.clamp();
	};

	// (protected) this *= n, this >= 0, 1 < n < DV
	BigInteger.prototype.dMultiply = function (n) {
		this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
		++this.t;
		this.clamp();
	};

	// (protected) this += n << w words, this >= 0
	BigInteger.prototype.dAddOffset = function (n, w) {
		if (n == 0) return;
		while (this.t <= w) this[this.t++] = 0;
		this[w] += n;
		while (this[w] >= this.DV) {
			this[w] -= this.DV;
			if (++w >= this.t) this[this.t++] = 0;
			++this[w];
		}
	};

	// (protected) r = lower n words of "this * a", a.t <= n
	// "this" should be the larger one if appropriate.
	BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
		var i = Math.min(this.t + a.t, n);
		r.s = 0; // assumes a,this >= 0
		r.t = i;
		while (i > 0) r[--i] = 0;
		var j;
		for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
		for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
		r.clamp();
	};


	// (protected) r = "this * a" without lower n words, n > 0
	// "this" should be the larger one if appropriate.
	BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
		--n;
		var i = r.t = this.t + a.t - n;
		r.s = 0; // assumes a,this >= 0
		while (--i >= 0) r[i] = 0;
		for (i = Math.max(n - this.t, 0); i < a.t; ++i)
			r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
		r.clamp();
		r.drShiftTo(1, r);
	};

	// (protected) this % n, n < 2^26
	BigInteger.prototype.modInt = function (n) {
		if (n <= 0) return 0;
		var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;
		if (this.t > 0)
			if (d == 0) r = this[0] % n;
			else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
		return r;
	};


	// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
	BigInteger.prototype.millerRabin = function (t) {
		var n1 = this.subtract(BigInteger.ONE);
		var k = n1.getLowestSetBit();
		if (k <= 0) return false;
		var r = n1.shiftRight(k);
		t = (t + 1) >> 1;
		if (t > lowprimes.length) t = lowprimes.length;
		var a = nbi();
		for (var i = 0; i < t; ++i) {
			//Pick bases at random, instead of starting at 2
			a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
			var y = a.modPow(r, this);
			if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
				var j = 1;
				while (j++ < k && y.compareTo(n1) != 0) {
					y = y.modPowInt(2, this);
					if (y.compareTo(BigInteger.ONE) == 0) return false;
				}
				if (y.compareTo(n1) != 0) return false;
			}
		}
		return true;
	};



	// (public)
	BigInteger.prototype.clone = function () { var r = nbi(); this.copyTo(r); return r; };

	// (public) return value as integer
	BigInteger.prototype.intValue = function () {
		if (this.s < 0) {
			if (this.t == 1) return this[0] - this.DV;
			else if (this.t == 0) return -1;
		}
		else if (this.t == 1) return this[0];
		else if (this.t == 0) return 0;
		// assumes 16 < DB < 32
		return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
	};


	// (public) return value as byte
	BigInteger.prototype.byteValue = function () { return (this.t == 0) ? this.s : (this[0] << 24) >> 24; };

	// (public) return value as short (assumes DB>=16)
	BigInteger.prototype.shortValue = function () { return (this.t == 0) ? this.s : (this[0] << 16) >> 16; };

	// (public) 0 if this == 0, 1 if this > 0
	BigInteger.prototype.signum = function () {
		if (this.s < 0) return -1;
		else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
		else return 1;
	};


	// (public) convert to bigendian byte array
	BigInteger.prototype.toByteArray = function () {
		var i = this.t, r = new Array();
		r[0] = this.s;
		var p = this.DB - (i * this.DB) % 8, d, k = 0;
		if (i-- > 0) {
			if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
				r[k++] = d | (this.s << (this.DB - p));
			while (i >= 0) {
				if (p < 8) {
					d = (this[i] & ((1 << p) - 1)) << (8 - p);
					d |= this[--i] >> (p += this.DB - 8);
				}
				else {
					d = (this[i] >> (p -= 8)) & 0xff;
					if (p <= 0) { p += this.DB; --i; }
				}
				if ((d & 0x80) != 0) d |= -256;
				if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;
				if (k > 0 || d != this.s) r[k++] = d;
			}
		}
		return r;
	};

	BigInteger.prototype.equals = function (a) { return (this.compareTo(a) == 0); };
	BigInteger.prototype.min = function (a) { return (this.compareTo(a) < 0) ? this : a; };
	BigInteger.prototype.max = function (a) { return (this.compareTo(a) > 0) ? this : a; };

	// (public) this & a
	function op_and(x, y) { return x & y; }
	BigInteger.prototype.and = function (a) { var r = nbi(); this.bitwiseTo(a, op_and, r); return r; };

	// (public) this | a
	function op_or(x, y) { return x | y; }
	BigInteger.prototype.or = function (a) { var r = nbi(); this.bitwiseTo(a, op_or, r); return r; };

	// (public) this ^ a
	function op_xor(x, y) { return x ^ y; }
	BigInteger.prototype.xor = function (a) { var r = nbi(); this.bitwiseTo(a, op_xor, r); return r; };

	// (public) this & ~a
	function op_andnot(x, y) { return x & ~y; }
	BigInteger.prototype.andNot = function (a) { var r = nbi(); this.bitwiseTo(a, op_andnot, r); return r; };

	// (public) ~this
	BigInteger.prototype.not = function () {
		var r = nbi();
		for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
		r.t = this.t;
		r.s = ~this.s;
		return r;
	};

	// (public) this << n
	BigInteger.prototype.shiftLeft = function (n) {
		var r = nbi();
		if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);
		return r;
	};

	// (public) this >> n
	BigInteger.prototype.shiftRight = function (n) {
		var r = nbi();
		if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);
		return r;
	};

	// (public) returns index of lowest 1-bit (or -1 if none)
	BigInteger.prototype.getLowestSetBit = function () {
		for (var i = 0; i < this.t; ++i)
			if (this[i] != 0) return i * this.DB + lbit(this[i]);
		if (this.s < 0) return this.t * this.DB;
		return -1;
	};

	// (public) return number of set bits
	BigInteger.prototype.bitCount = function () {
		var r = 0, x = this.s & this.DM;
		for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
		return r;
	};

	// (public) true iff nth bit is set
	BigInteger.prototype.testBit = function (n) {
		var j = Math.floor(n / this.DB);
		if (j >= this.t) return (this.s != 0);
		return ((this[j] & (1 << (n % this.DB))) != 0);
	};

	// (public) this | (1<<n)
	BigInteger.prototype.setBit = function (n) { return this.changeBit(n, op_or); };
	// (public) this & ~(1<<n)
	BigInteger.prototype.clearBit = function (n) { return this.changeBit(n, op_andnot); };
	// (public) this ^ (1<<n)
	BigInteger.prototype.flipBit = function (n) { return this.changeBit(n, op_xor); };
	// (public) this + a
	BigInteger.prototype.add = function (a) { var r = nbi(); this.addTo(a, r); return r; };
	// (public) this - a
	BigInteger.prototype.subtract = function (a) { var r = nbi(); this.subTo(a, r); return r; };
	// (public) this * a
	BigInteger.prototype.multiply = function (a) { var r = nbi(); this.multiplyTo(a, r); return r; };
	// (public) this / a
	BigInteger.prototype.divide = function (a) { var r = nbi(); this.divRemTo(a, r, null); return r; };
	// (public) this % a
	BigInteger.prototype.remainder = function (a) { var r = nbi(); this.divRemTo(a, null, r); return r; };
	// (public) [this/a,this%a]
	BigInteger.prototype.divideAndRemainder = function (a) {
		var q = nbi(), r = nbi();
		this.divRemTo(a, q, r);
		return new Array(q, r);
	};

	// (public) this^e % m (HAC 14.85)
	BigInteger.prototype.modPow = function (e, m) {
		var i = e.bitLength(), k, r = nbv(1), z;
		if (i <= 0) return r;
		else if (i < 18) k = 1;
		else if (i < 48) k = 3;
		else if (i < 144) k = 4;
		else if (i < 768) k = 5;
		else k = 6;
		if (i < 8)
			z = new Classic(m);
		else if (m.isEven())
			z = new Barrett(m);
		else
			z = new Montgomery(m);

		// precomputation
		var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
		g[1] = z.convert(this);
		if (k > 1) {
			var g2 = nbi();
			z.sqrTo(g[1], g2);
			while (n <= km) {
				g[n] = nbi();
				z.mulTo(g2, g[n - 2], g[n]);
				n += 2;
			}
		}

		var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
		i = nbits(e[j]) - 1;
		while (j >= 0) {
			if (i >= k1) w = (e[j] >> (i - k1)) & km;
			else {
				w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
				if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
			}

			n = k;
			while ((w & 1) == 0) { w >>= 1; --n; }
			if ((i -= n) < 0) { i += this.DB; --j; }
			if (is1) {	// ret == 1, don't bother squaring or multiplying it
				g[w].copyTo(r);
				is1 = false;
			}
			else {
				while (n > 1) { z.sqrTo(r, r2); z.sqrTo(r2, r); n -= 2; }
				if (n > 0) z.sqrTo(r, r2); else { t = r; r = r2; r2 = t; }
				z.mulTo(r2, g[w], r);
			}

			while (j >= 0 && (e[j] & (1 << i)) == 0) {
				z.sqrTo(r, r2); t = r; r = r2; r2 = t;
				if (--i < 0) { i = this.DB - 1; --j; }
			}
		}
		return z.revert(r);
	};

	// (public) 1/this % m (HAC 14.61)
	BigInteger.prototype.modInverse = function (m) {
		var ac = m.isEven();
		if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
		var u = m.clone(), v = this.clone();
		var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
		while (u.signum() != 0) {
			while (u.isEven()) {
				u.rShiftTo(1, u);
				if (ac) {
					if (!a.isEven() || !b.isEven()) { a.addTo(this, a); b.subTo(m, b); }
					a.rShiftTo(1, a);
				}
				else if (!b.isEven()) b.subTo(m, b);
				b.rShiftTo(1, b);
			}
			while (v.isEven()) {
				v.rShiftTo(1, v);
				if (ac) {
					if (!c.isEven() || !d.isEven()) { c.addTo(this, c); d.subTo(m, d); }
					c.rShiftTo(1, c);
				}
				else if (!d.isEven()) d.subTo(m, d);
				d.rShiftTo(1, d);
			}
			if (u.compareTo(v) >= 0) {
				u.subTo(v, u);
				if (ac) a.subTo(c, a);
				b.subTo(d, b);
			}
			else {
				v.subTo(u, v);
				if (ac) c.subTo(a, c);
				d.subTo(b, d);
			}
		}
		if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
		if (d.compareTo(m) >= 0) return d.subtract(m);
		if (d.signum() < 0) d.addTo(m, d); else return d;
		if (d.signum() < 0) return d.add(m); else return d;
	};


	// (public) this^e
	BigInteger.prototype.pow = function (e) { return this.exp(e, new NullExp()); };

	// (public) gcd(this,a) (HAC 14.54)
	BigInteger.prototype.gcd = function (a) {
		var x = (this.s < 0) ? this.negate() : this.clone();
		var y = (a.s < 0) ? a.negate() : a.clone();
		if (x.compareTo(y) < 0) { var t = x; x = y; y = t; }
		var i = x.getLowestSetBit(), g = y.getLowestSetBit();
		if (g < 0) return x;
		if (i < g) g = i;
		if (g > 0) {
			x.rShiftTo(g, x);
			y.rShiftTo(g, y);
		}
		while (x.signum() > 0) {
			if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
			if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
			if (x.compareTo(y) >= 0) {
				x.subTo(y, x);
				x.rShiftTo(1, x);
			}
			else {
				y.subTo(x, y);
				y.rShiftTo(1, y);
			}
		}
		if (g > 0) y.lShiftTo(g, y);
		return y;
	};

	// (public) test primality with certainty >= 1-.5^t
	BigInteger.prototype.isProbablePrime = function (t) {
		var i, x = this.abs();
		if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
			for (i = 0; i < lowprimes.length; ++i)
				if (x[0] == lowprimes[i]) return true;
			return false;
		}
		if (x.isEven()) return false;
		i = 1;
		while (i < lowprimes.length) {
			var m = lowprimes[i], j = i + 1;
			while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
			m = x.modInt(m);
			while (i < j) if (m % lowprimes[i++] == 0) return false;
		}
		return x.millerRabin(t);
	};


	// JSBN-specific extension

	// (public) this^2
	BigInteger.prototype.square = function () { var r = nbi(); this.squareTo(r); return r; };


	// NOTE: BigInteger interfaces not implemented in jsbn:
	// BigInteger(int signum, byte[] magnitude)
	// double doubleValue()
	// float floatValue()
	// int hashCode()
	// long longValue()
	// static BigInteger valueOf(long val)



	// Copyright Stephan Thomas (start) --- //
	// https://raw.github.com/bitcoinjs/bitcoinjs-lib/07f9d55ccb6abd962efb6befdd37671f85ea4ff9/src/util.js
	// BigInteger monkey patching
	BigInteger.valueOf = nbv;

	/**
	* Returns a byte array representation of the big integer.
	*
	* This returns the absolute of the contained value in big endian
	* form. A value of zero results in an empty array.
	*/
	BigInteger.prototype.toByteArrayUnsigned = function () {
		var ba = this.abs().toByteArray();
		if (ba.length) {
			if (ba[0] == 0) {
				ba = ba.slice(1);
			}
			return ba.map(function (v) {
				return (v < 0) ? v + 256 : v;
			});
		} else {
			// Empty array, nothing to do
			return ba;
		}
	};

	/**
	* Turns a byte array into a big integer.
	*
	* This function will interpret a byte array as a big integer in big
	* endian notation and ignore leading zeros.
	*/
	BigInteger.fromByteArrayUnsigned = function (ba) {
		if (!ba.length) {
			return ba.valueOf(0);
		} else if (ba[0] & 0x80) {
			// Prepend a zero so the BigInteger class doesn't mistake this
			// for a negative integer.
			return new BigInteger([0].concat(ba));
		} else {
			return new BigInteger(ba);
		}
	};

	/**
	* Converts big integer to signed byte representation.
	*
	* The format for this value uses a the most significant bit as a sign
	* bit. If the most significant bit is already occupied by the
	* absolute value, an extra byte is prepended and the sign bit is set
	* there.
	*
	* Examples:
	*
	*      0 =>     0x00
	*      1 =>     0x01
	*     -1 =>     0x81
	*    127 =>     0x7f
	*   -127 =>     0xff
	*    128 =>   0x0080
	*   -128 =>   0x8080
	*    255 =>   0x00ff
	*   -255 =>   0x80ff
	*  16300 =>   0x3fac
	* -16300 =>   0xbfac
	*  62300 => 0x00f35c
	* -62300 => 0x80f35c
	*/
	BigInteger.prototype.toByteArraySigned = function () {
		var val = this.abs().toByteArrayUnsigned();
		var neg = this.compareTo(BigInteger.ZERO) < 0;

		if (neg) {
			if (val[0] & 0x80) {
				val.unshift(0x80);
			} else {
				val[0] |= 0x80;
			}
		} else {
			if (val[0] & 0x80) {
				val.unshift(0x00);
			}
		}

		return val;
	};

	/**
	* Parse a signed big integer byte representation.
	*
	* For details on the format please see BigInteger.toByteArraySigned.
	*/
	BigInteger.fromByteArraySigned = function (ba) {
		// Check for negative value
		if (ba[0] & 0x80) {
			// Remove sign bit
			ba[0] &= 0x7f;

			return BigInteger.fromByteArrayUnsigned(ba).negate();
		} else {
			return BigInteger.fromByteArrayUnsigned(ba);
		}
	};
	// Copyright Stephan Thomas (end) --- //




	// ****** REDUCTION ******* //

	// Modular reduction using "classic" algorithm
	function Classic(m) { this.m = m; }
	Classic.prototype.convert = function (x) {
		if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
		else return x;
	};
	Classic.prototype.revert = function (x) { return x; };
	Classic.prototype.reduce = function (x) { x.divRemTo(this.m, null, x); };
	Classic.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
	Classic.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };





	// Montgomery reduction
	function Montgomery(m) {
		this.m = m;
		this.mp = m.invDigit();
		this.mpl = this.mp & 0x7fff;
		this.mph = this.mp >> 15;
		this.um = (1 << (m.DB - 15)) - 1;
		this.mt2 = 2 * m.t;
	}
	// xR mod m
	Montgomery.prototype.convert = function (x) {
		var r = nbi();
		x.abs().dlShiftTo(this.m.t, r);
		r.divRemTo(this.m, null, r);
		if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
		return r;
	}
	// x/R mod m
	Montgomery.prototype.revert = function (x) {
		var r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	};
	// x = x/R mod m (HAC 14.32)
	Montgomery.prototype.reduce = function (x) {
		while (x.t <= this.mt2)	// pad x so am has enough room later
			x[x.t++] = 0;
		for (var i = 0; i < this.m.t; ++i) {
			// faster way of calculating u0 = x[i]*mp mod DV
			var j = x[i] & 0x7fff;
			var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
			// use am to combine the multiply-shift-add into one call
			j = i + this.m.t;
			x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
			// propagate carry
			while (x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
		}
		x.clamp();
		x.drShiftTo(this.m.t, x);
		if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	};
	// r = "xy/R mod m"; x,y != r
	Montgomery.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
	// r = "x^2/R mod m"; x != r
	Montgomery.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };





	// A "null" reducer
	function NullExp() { }
	NullExp.prototype.convert = function (x) { return x; };
	NullExp.prototype.revert = function (x) { return x; };
	NullExp.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); };
	NullExp.prototype.sqrTo = function (x, r) { x.squareTo(r); };





	// Barrett modular reduction
	function Barrett(m) {
		// setup Barrett
		this.r2 = nbi();
		this.q3 = nbi();
		BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
		this.mu = this.r2.divide(m);
		this.m = m;
	}
	Barrett.prototype.convert = function (x) {
		if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
		else if (x.compareTo(this.m) < 0) return x;
		else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
	};
	Barrett.prototype.revert = function (x) { return x; };
	// x = x mod m (HAC 14.42)
	Barrett.prototype.reduce = function (x) {
		x.drShiftTo(this.m.t - 1, this.r2);
		if (x.t > this.m.t + 1) { x.t = this.m.t + 1; x.clamp(); }
		this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
		this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
		while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
		x.subTo(this.r2, x);
		while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	};
	// r = x*y mod m; x,y != r
	Barrett.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
	// r = x^2 mod m; x != r
	Barrett.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };

})(exports);

var BigInteger = exports.BigInteger;
/*!
* Crypto-JS v2.5.4	Crypto.js
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*/

(function (Crypto) {

	var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	// Crypto utilities
	var util = Crypto.util = {

		// Bit-wise rotate left
		rotl: function (n, b) {
			return (n << b) | (n >>> (32 - b));
		},

		// Bit-wise rotate right
		rotr: function (n, b) {
			return (n << (32 - b)) | (n >>> b);
		},

		// Swap big-endian to little-endian and vice versa
		endian: function (n) {

			// If number given, swap endian
			if (n.constructor == Number) {
				return util.rotl(n, 8) & 0x00FF00FF |
		    util.rotl(n, 24) & 0xFF00FF00;
			}

			// Else, assume array and swap all items
			for (var i = 0; i < n.length; i++)
				n[i] = util.endian(n[i]);
			return n;

		},

		// Generate an array of any length of random bytes
		randomBytes: function (n) {
			for (var bytes = []; n > 0; n--)
				bytes.push(Math.floor(Math.random() * 256));
			return bytes;
		},

		// Convert a byte array to big-endian 32-bit words
		bytesToWords: function (bytes) {
			for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
				words[b >>> 5] |= (bytes[i] & 0xFF) << (24 - b % 32);
			return words;
		},

		// Convert big-endian 32-bit words to a byte array
		wordsToBytes: function (words) {
			for (var bytes = [], b = 0; b < words.length * 32; b += 8)
				bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
			return bytes;
		},

		// Convert a byte array to a hex string
		bytesToHex: function (bytes) {
			for (var hex = [], i = 0; i < bytes.length; i++) {
				hex.push((bytes[i] >>> 4).toString(16));
				hex.push((bytes[i] & 0xF).toString(16));
			}
			return hex.join("");
		},

		// Convert a hex string to a byte array
		hexToBytes: function (hex) {
			for (var bytes = [], c = 0; c < hex.length; c += 2)
				bytes.push(parseInt(hex.substr(c, 2), 16));
			return bytes;
		},

		// Convert a byte array to a base-64 string
		bytesToBase64: function (bytes) {
			for (var base64 = [], i = 0; i < bytes.length; i += 3) {
				var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
				for (var j = 0; j < 4; j++) {
					if (i * 8 + j * 6 <= bytes.length * 8)
						base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
					else base64.push("=");
				}
			}

			return base64.join("");
		},

		// Convert a base-64 string to a byte array
		base64ToBytes: function (base64) {
			// Remove non-base-64 characters
			base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");

			for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
				if (imod4 == 0) continue;
				bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) |
		        (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
			}

			return bytes;
		}

	};

	// Crypto character encodings
	var charenc = Crypto.charenc = {};

	// UTF-8 encoding
	var UTF8 = charenc.UTF8 = {

		// Convert a string to a byte array
		stringToBytes: function (str) {
			return Binary.stringToBytes(unescape(encodeURIComponent(str)));
		},

		// Convert a byte array to a string
		bytesToString: function (bytes) {
			return decodeURIComponent(escape(Binary.bytesToString(bytes)));
		}

	};

	// Binary encoding
	var Binary = charenc.Binary = {

		// Convert a string to a byte array
		stringToBytes: function (str) {
			for (var bytes = [], i = 0; i < str.length; i++)
				bytes.push(str.charCodeAt(i) & 0xFF);
			return bytes;
		},

		// Convert a byte array to a string
		bytesToString: function (bytes) {
			for (var str = [], i = 0; i < bytes.length; i++)
				str.push(String.fromCharCode(bytes[i]));
			return str.join("");
		}

	};

})(Crypto);
/*!
* Crypto-JS v2.0.0  RIPEMD-160
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*
* A JavaScript implementation of the RIPEMD-160 Algorithm
* Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.
* Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
* Distributed under the BSD License
* See http://pajhome.org.uk/crypt/md5 for details.
* Also http://www.ocf.berkeley.edu/~jjlin/jsotp/
* Ported to Crypto-JS by Stefan Thomas.
*/

(function (Crypto) {
	// Shortcuts
	var C = Crypto,
	util = C.util,
	charenc = C.charenc,
	UTF8 = charenc.UTF8,
	Binary = charenc.Binary;

	// Convert a byte array to little-endian 32-bit words
	util.bytesToLWords = function (bytes) {

		var output = Array(bytes.length >> 2);
		for (var i = 0; i < output.length; i++)
			output[i] = 0;
		for (var i = 0; i < bytes.length * 8; i += 8)
			output[i >> 5] |= (bytes[i / 8] & 0xFF) << (i % 32);
		return output;
	};

	// Convert little-endian 32-bit words to a byte array
	util.lWordsToBytes = function (words) {
		var output = [];
		for (var i = 0; i < words.length * 32; i += 8)
			output.push((words[i >> 5] >>> (i % 32)) & 0xff);
		return output;
	};

	// Public API
	var RIPEMD160 = C.RIPEMD160 = function (message, options) {
		var digestbytes = util.lWordsToBytes(RIPEMD160._rmd160(message));
		return options && options.asBytes ? digestbytes :
			options && options.asString ? Binary.bytesToString(digestbytes) :
			util.bytesToHex(digestbytes);
	};

	// The core
	RIPEMD160._rmd160 = function (message) {
		// Convert to byte array
		if (message.constructor == String) message = UTF8.stringToBytes(message);

		var x = util.bytesToLWords(message),
			len = message.length * 8;

		/* append padding */
		x[len >> 5] |= 0x80 << (len % 32);
		x[(((len + 64) >>> 9) << 4) + 14] = len;

		var h0 = 0x67452301;
		var h1 = 0xefcdab89;
		var h2 = 0x98badcfe;
		var h3 = 0x10325476;
		var h4 = 0xc3d2e1f0;

		for (var i = 0; i < x.length; i += 16) {
			var T;
			var A1 = h0, B1 = h1, C1 = h2, D1 = h3, E1 = h4;
			var A2 = h0, B2 = h1, C2 = h2, D2 = h3, E2 = h4;
			for (var j = 0; j <= 79; ++j) {
				T = safe_add(A1, rmd160_f(j, B1, C1, D1));
				T = safe_add(T, x[i + rmd160_r1[j]]);
				T = safe_add(T, rmd160_K1(j));
				T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
				A1 = E1; E1 = D1; D1 = bit_rol(C1, 10); C1 = B1; B1 = T;
				T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2));
				T = safe_add(T, x[i + rmd160_r2[j]]);
				T = safe_add(T, rmd160_K2(j));
				T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
				A2 = E2; E2 = D2; D2 = bit_rol(C2, 10); C2 = B2; B2 = T;
			}
			T = safe_add(h1, safe_add(C1, D2));
			h1 = safe_add(h2, safe_add(D1, E2));
			h2 = safe_add(h3, safe_add(E1, A2));
			h3 = safe_add(h4, safe_add(A1, B2));
			h4 = safe_add(h0, safe_add(B1, C2));
			h0 = T;
		}
		return [h0, h1, h2, h3, h4];
	}

	function rmd160_f(j, x, y, z) {
		return (0 <= j && j <= 15) ? (x ^ y ^ z) :
			(16 <= j && j <= 31) ? (x & y) | (~x & z) :
			(32 <= j && j <= 47) ? (x | ~y) ^ z :
			(48 <= j && j <= 63) ? (x & z) | (y & ~z) :
			(64 <= j && j <= 79) ? x ^ (y | ~z) :
			"rmd160_f: j out of range";
	}
	function rmd160_K1(j) {
		return (0 <= j && j <= 15) ? 0x00000000 :
			(16 <= j && j <= 31) ? 0x5a827999 :
			(32 <= j && j <= 47) ? 0x6ed9eba1 :
			(48 <= j && j <= 63) ? 0x8f1bbcdc :
			(64 <= j && j <= 79) ? 0xa953fd4e :
			"rmd160_K1: j out of range";
	}
	function rmd160_K2(j) {
		return (0 <= j && j <= 15) ? 0x50a28be6 :
			(16 <= j && j <= 31) ? 0x5c4dd124 :
			(32 <= j && j <= 47) ? 0x6d703ef3 :
			(48 <= j && j <= 63) ? 0x7a6d76e9 :
			(64 <= j && j <= 79) ? 0x00000000 :
			"rmd160_K2: j out of range";
	}
	var rmd160_r1 = [
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
		7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
		3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
		1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
		4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];
	var rmd160_r2 = [
		5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
		6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
		15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
		8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
		12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];
	var rmd160_s1 = [
		11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
		7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
		11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
		11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
		9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];
	var rmd160_s2 = [
		8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
		9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
		9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
		15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
		8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

	/*
	* Add integers, wrapping at 2^32. This uses 16-bit operations internally
	* to work around bugs in some JS interpreters.
	*/
	function safe_add(x, y) {
		var lsw = (x & 0xFFFF) + (y & 0xFFFF);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	* Bitwise rotate a 32-bit number to the left.
	*/
	function bit_rol(num, cnt) {
		return (num << cnt) | (num >>> (32 - cnt));
	}
})(Crypto);/*!
* Crypto-JS v2.5.4	SHA256.js
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*/
(function (Crypto) {

	// Shortcuts
	var C = Crypto,
		util = C.util,
		charenc = C.charenc,
		UTF8 = charenc.UTF8,
		Binary = charenc.Binary;

	// Constants
	var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
        0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
        0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
        0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
        0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
        0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
        0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
        0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
        0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];

	// Public API
	var SHA256 = C.SHA256 = function (message, options) {
		var digestbytes = util.wordsToBytes(SHA256._sha256(message));
		return options && options.asBytes ? digestbytes :
	    options && options.asString ? Binary.bytesToString(digestbytes) :
	    util.bytesToHex(digestbytes);
	};

	// The core
	SHA256._sha256 = function (message) {

		// Convert to byte array
		if (message.constructor == String) message = UTF8.stringToBytes(message);
		/* else, assume byte array already */

		var m = util.bytesToWords(message),
		l = message.length * 8,
		H = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
				0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19],
		w = [],
		a, b, c, d, e, f, g, h, i, j,
		t1, t2;

		// Padding
		m[l >> 5] |= 0x80 << (24 - l % 32);
		m[((l + 64 >> 9) << 4) + 15] = l;

		for (var i = 0; i < m.length; i += 16) {

			a = H[0];
			b = H[1];
			c = H[2];
			d = H[3];
			e = H[4];
			f = H[5];
			g = H[6];
			h = H[7];

			for (var j = 0; j < 64; j++) {

				if (j < 16) w[j] = m[j + i];
				else {

					var gamma0x = w[j - 15],
				gamma1x = w[j - 2],
				gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^
				            ((gamma0x << 14) | (gamma0x >>> 18)) ^
				            (gamma0x >>> 3),
				gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^
				            ((gamma1x << 13) | (gamma1x >>> 19)) ^
				            (gamma1x >>> 10);

					w[j] = gamma0 + (w[j - 7] >>> 0) +
				    gamma1 + (w[j - 16] >>> 0);

				}

				var ch = e & f ^ ~e & g,
			maj = a & b ^ a & c ^ b & c,
			sigma0 = ((a << 30) | (a >>> 2)) ^
			            ((a << 19) | (a >>> 13)) ^
			            ((a << 10) | (a >>> 22)),
			sigma1 = ((e << 26) | (e >>> 6)) ^
			            ((e << 21) | (e >>> 11)) ^
			            ((e << 7) | (e >>> 25));


				t1 = (h >>> 0) + sigma1 + ch + (K[j]) + (w[j] >>> 0);
				t2 = sigma0 + maj;

				h = g;
				g = f;
				f = e;
				e = (d + t1) >>> 0;
				d = c;
				c = b;
				b = a;
				a = (t1 + t2) >>> 0;

			}

			H[0] += a;
			H[1] += b;
			H[2] += c;
			H[3] += d;
			H[4] += e;
			H[5] += f;
			H[6] += g;
			H[7] += h;

		}

		return H;

	};

	// Package private blocksize
	SHA256._blocksize = 16;

	SHA256._digestsize = 32;

})(Crypto);//https://raw.github.com/bitcoinjs/bitcoinjs-lib/faa10f0f6a1fff0b9a99fffb9bc30cee33b17212/src/ecdsa.js
/*!
* Basic Javascript Elliptic Curve implementation
* Ported loosely from BouncyCastle's Java EC code
* Only Fp curves implemented for now
* 
* Copyright Tom Wu, bitaddress.org  BSD License.
* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
*/
(function (exports) {

	// Constructor function of Global EllipticCurve object
	var ec = exports.EllipticCurve = function () { };

	// ----------------
	// ECFieldElementFp constructor
	// q instanceof BigInteger
	// x instanceof BigInteger
	ec.FieldElementFp = function (q, x) {
		this.x = x;
		// TODO if(x.compareTo(q) >= 0) error
		this.q = q;
	};

	ec.FieldElementFp.prototype.equals = function (other) {
		if (other == this) return true;
		return (this.q.equals(other.q) && this.x.equals(other.x));
	};

	ec.FieldElementFp.prototype.toBigInteger = function () {
		return this.x;
	};

	ec.FieldElementFp.prototype.negate = function () {
		return new ec.FieldElementFp(this.q, this.x.negate().mod(this.q));
	};

	ec.FieldElementFp.prototype.add = function (b) {
		return new ec.FieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
	};

	ec.FieldElementFp.prototype.subtract = function (b) {
		return new ec.FieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
	};

	ec.FieldElementFp.prototype.multiply = function (b) {
		return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
	};

	ec.FieldElementFp.prototype.square = function () {
		return new ec.FieldElementFp(this.q, this.x.square().mod(this.q));
	};

	ec.FieldElementFp.prototype.divide = function (b) {
		return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
	};

	ec.FieldElementFp.prototype.getByteLength = function () {
		return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
	};

	// D.1.4 91
	/**
	* return a sqrt root - the routine verifies that the calculation
	* returns the right value - if none exists it returns null.
	* 
	* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
	* Ported to JavaScript by bitaddress.org
	*/
	ec.FieldElementFp.prototype.sqrt = function () {
		throw new Error("this feature is disabled since we don't have a randomness source");
		if (!this.q.testBit(0)) throw new Error("even value of q");

		// p mod 4 == 3
		if (this.q.testBit(1)) {
			// z = g^(u+1) + p, p = 4u + 3
			var z = new ec.FieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
			return z.square().equals(this) ? z : null;
		}

		// p mod 4 == 1
		var qMinusOne = this.q.subtract(BigInteger.ONE);
		var legendreExponent = qMinusOne.shiftRight(1);
		if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE))) return null;
		var u = qMinusOne.shiftRight(2);
		var k = u.shiftLeft(1).add(BigInteger.ONE);
		var Q = this.x;
		var fourQ = Q.shiftLeft(2).mod(this.q);
		var U, V;

		do {
			var rand = new SecureRandom();
			var P;
			do {
				P = new BigInteger(this.q.bitLength(), rand);
			}
			while (P.compareTo(this.q) >= 0 || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));

			var result = ec.FieldElementFp.fastLucasSequence(this.q, P, Q, k);

			U = result[0];
			V = result[1];
			if (V.multiply(V).mod(this.q).equals(fourQ)) {
				// Integer division by 2, mod q
				if (V.testBit(0)) {
					V = V.add(this.q);
				}
				V = V.shiftRight(1);
				return new ec.FieldElementFp(this.q, V);
			}
		}
		while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));

		return null;
	};

	/*
	* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
	* Ported to JavaScript by bitaddress.org
	*/
	ec.FieldElementFp.fastLucasSequence = function (p, P, Q, k) {
		// TODO Research and apply "common-multiplicand multiplication here"

		var n = k.bitLength();
		var s = k.getLowestSetBit();
		var Uh = BigInteger.ONE;
		var Vl = BigInteger.TWO;
		var Vh = P;
		var Ql = BigInteger.ONE;
		var Qh = BigInteger.ONE;

		for (var j = n - 1; j >= s + 1; --j) {
			Ql = Ql.multiply(Qh).mod(p);
			if (k.testBit(j)) {
				Qh = Ql.multiply(Q).mod(p);
				Uh = Uh.multiply(Vh).mod(p);
				Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
				Vh = Vh.multiply(Vh).subtract(Qh.shiftLeft(1)).mod(p);
			}
			else {
				Qh = Ql;
				Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
				Vh = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
				Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
			}
		}

		Ql = Ql.multiply(Qh).mod(p);
		Qh = Ql.multiply(Q).mod(p);
		Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
		Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
		Ql = Ql.multiply(Qh).mod(p);

		for (var j = 1; j <= s; ++j) {
			Uh = Uh.multiply(Vl).mod(p);
			Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
			Ql = Ql.multiply(Ql).mod(p);
		}

		return [Uh, Vl];
	};

	// ----------------
	// ECPointFp constructor
	ec.PointFp = function (curve, x, y, z, compressed) {
		this.curve = curve;
		this.x = x;
		this.y = y;
		// Projective coordinates: either zinv == null or z * zinv == 1
		// z and zinv are just BigIntegers, not fieldElements
		if (z == null) {
			this.z = BigInteger.ONE;
		}
		else {
			this.z = z;
		}
		this.zinv = null;
		// compression flag
		this.compressed = !!compressed;
	};

	ec.PointFp.prototype.getX = function () {
		if (this.zinv == null) {
			this.zinv = this.z.modInverse(this.curve.q);
		}
		return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));
	};

	ec.PointFp.prototype.getY = function () {
		if (this.zinv == null) {
			this.zinv = this.z.modInverse(this.curve.q);
		}
		return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));
	};

	ec.PointFp.prototype.equals = function (other) {
		if (other == this) return true;
		if (this.isInfinity()) return other.isInfinity();
		if (other.isInfinity()) return this.isInfinity();
		var u, v;
		// u = Y2 * Z1 - Y1 * Z2
		u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
		if (!u.equals(BigInteger.ZERO)) return false;
		// v = X2 * Z1 - X1 * Z2
		v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
		return v.equals(BigInteger.ZERO);
	};

	ec.PointFp.prototype.isInfinity = function () {
		if ((this.x == null) && (this.y == null)) return true;
		return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
	};

	ec.PointFp.prototype.negate = function () {
		return new ec.PointFp(this.curve, this.x, this.y.negate(), this.z);
	};

	ec.PointFp.prototype.add = function (b) {
		if (this.isInfinity()) return b;
		if (b.isInfinity()) return this;

		// u = Y2 * Z1 - Y1 * Z2
		var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
		// v = X2 * Z1 - X1 * Z2
		var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);


		if (BigInteger.ZERO.equals(v)) {
			if (BigInteger.ZERO.equals(u)) {
				return this.twice(); // this == b, so double
			}
			return this.curve.getInfinity(); // this = -b, so infinity
		}

		var THREE = new BigInteger("3");
		var x1 = this.x.toBigInteger();
		var y1 = this.y.toBigInteger();
		var x2 = b.x.toBigInteger();
		var y2 = b.y.toBigInteger();

		var v2 = v.square();
		var v3 = v2.multiply(v);
		var x1v2 = x1.multiply(v2);
		var zu2 = u.square().multiply(this.z);

		// x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
		var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
		// y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
		var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
		// z3 = v^3 * z1 * z2
		var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

		return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
	};

	ec.PointFp.prototype.twice = function () {
		if (this.isInfinity()) return this;
		if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

		// TODO: optimized handling of constants
		var THREE = new BigInteger("3");
		var x1 = this.x.toBigInteger();
		var y1 = this.y.toBigInteger();

		var y1z1 = y1.multiply(this.z);
		var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
		var a = this.curve.a.toBigInteger();

		// w = 3 * x1^2 + a * z1^2
		var w = x1.square().multiply(THREE);
		if (!BigInteger.ZERO.equals(a)) {
			w = w.add(this.z.square().multiply(a));
		}
		w = w.mod(this.curve.q);
		// x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
		var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
		// y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
		var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
		// z3 = 8 * (y1 * z1)^3
		var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

		return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
	};

	// Simple NAF (Non-Adjacent Form) multiplication algorithm
	// TODO: modularize the multiplication algorithm
	ec.PointFp.prototype.multiply = function (k) {
		if (this.isInfinity()) return this;
		if (k.signum() == 0) return this.curve.getInfinity();

		var e = k;
		var h = e.multiply(new BigInteger("3"));

		var neg = this.negate();
		var R = this;

		var i;
		for (i = h.bitLength() - 2; i > 0; --i) {
			R = R.twice();

			var hBit = h.testBit(i);
			var eBit = e.testBit(i);

			if (hBit != eBit) {
				R = R.add(hBit ? this : neg);
			}
		}

		return R;
	};

	// Compute this*j + x*k (simultaneous multiplication)
	ec.PointFp.prototype.multiplyTwo = function (j, x, k) {
		var i;
		if (j.bitLength() > k.bitLength())
			i = j.bitLength() - 1;
		else
			i = k.bitLength() - 1;

		var R = this.curve.getInfinity();
		var both = this.add(x);
		while (i >= 0) {
			R = R.twice();
			if (j.testBit(i)) {
				if (k.testBit(i)) {
					R = R.add(both);
				}
				else {
					R = R.add(this);
				}
			}
			else {
				if (k.testBit(i)) {
					R = R.add(x);
				}
			}
			--i;
		}

		return R;
	};

	// patched by bitaddress.org and Casascius for use with Bitcoin.ECKey
	// patched by coretechs to support compressed public keys
	ec.PointFp.prototype.getEncoded = function (compressed) {
		var x = this.getX().toBigInteger();
		var y = this.getY().toBigInteger();
		var len = 32; // integerToBytes will zero pad if integer is less than 32 bytes. 32 bytes length is required by the Bitcoin protocol.
		var enc = ec.integerToBytes(x, len);

		// when compressed prepend byte depending if y point is even or odd 
		if (compressed) {
			if (y.isEven()) {
				enc.unshift(0x02);
			}
			else {
				enc.unshift(0x03);
			}
		}
		else {
			enc.unshift(0x04);
			enc = enc.concat(ec.integerToBytes(y, len)); // uncompressed public key appends the bytes of the y point
		}
		return enc;
	};

	ec.PointFp.decodeFrom = function (curve, enc) {
		var type = enc[0];
		var dataLen = enc.length - 1;

		// Extract x and y as byte arrays
		var xBa = enc.slice(1, 1 + dataLen / 2);
		var yBa = enc.slice(1 + dataLen / 2, 1 + dataLen);

		// Prepend zero byte to prevent interpretation as negative integer
		xBa.unshift(0);
		yBa.unshift(0);

		// Convert to BigIntegers
		var x = new BigInteger(xBa);
		var y = new BigInteger(yBa);

		// Return point
		return new ec.PointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
	};

	ec.PointFp.prototype.add2D = function (b) {
		if (this.isInfinity()) return b;
		if (b.isInfinity()) return this;

		if (this.x.equals(b.x)) {
			if (this.y.equals(b.y)) {
				// this = b, i.e. this must be doubled
				return this.twice();
			}
			// this = -b, i.e. the result is the point at infinity
			return this.curve.getInfinity();
		}

		var x_x = b.x.subtract(this.x);
		var y_y = b.y.subtract(this.y);
		var gamma = y_y.divide(x_x);

		var x3 = gamma.square().subtract(this.x).subtract(b.x);
		var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

		return new ec.PointFp(this.curve, x3, y3);
	};

	ec.PointFp.prototype.twice2D = function () {
		if (this.isInfinity()) return this;
		if (this.y.toBigInteger().signum() == 0) {
			// if y1 == 0, then (x1, y1) == (x1, -y1)
			// and hence this = -this and thus 2(x1, y1) == infinity
			return this.curve.getInfinity();
		}

		var TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));
		var THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));
		var gamma = this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));

		var x3 = gamma.square().subtract(this.x.multiply(TWO));
		var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

		return new ec.PointFp(this.curve, x3, y3);
	};

	ec.PointFp.prototype.multiply2D = function (k) {
		if (this.isInfinity()) return this;
		if (k.signum() == 0) return this.curve.getInfinity();

		var e = k;
		var h = e.multiply(new BigInteger("3"));

		var neg = this.negate();
		var R = this;

		var i;
		for (i = h.bitLength() - 2; i > 0; --i) {
			R = R.twice();

			var hBit = h.testBit(i);
			var eBit = e.testBit(i);

			if (hBit != eBit) {
				R = R.add2D(hBit ? this : neg);
			}
		}

		return R;
	};

	ec.PointFp.prototype.isOnCurve = function () {
		var x = this.getX().toBigInteger();
		var y = this.getY().toBigInteger();
		var a = this.curve.getA().toBigInteger();
		var b = this.curve.getB().toBigInteger();
		var n = this.curve.getQ();
		var lhs = y.multiply(y).mod(n);
		var rhs = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(n);
		return lhs.equals(rhs);
	};

	ec.PointFp.prototype.toString = function () {
		return '(' + this.getX().toBigInteger().toString() + ',' + this.getY().toBigInteger().toString() + ')';
	};

	/**
	* Validate an elliptic curve point.
	*
	* See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
	*/
	ec.PointFp.prototype.validate = function () {
		var n = this.curve.getQ();

		// Check Q != O
		if (this.isInfinity()) {
			throw new Error("Point is at infinity.");
		}

		// Check coordinate bounds
		var x = this.getX().toBigInteger();
		var y = this.getY().toBigInteger();
		if (x.compareTo(BigInteger.ONE) < 0 || x.compareTo(n.subtract(BigInteger.ONE)) > 0) {
			throw new Error('x coordinate out of bounds');
		}
		if (y.compareTo(BigInteger.ONE) < 0 || y.compareTo(n.subtract(BigInteger.ONE)) > 0) {
			throw new Error('y coordinate out of bounds');
		}

		// Check y^2 = x^3 + ax + b (mod n)
		if (!this.isOnCurve()) {
			throw new Error("Point is not on the curve.");
		}

		// Check nQ = 0 (Q is a scalar multiple of G)
		if (this.multiply(n).isInfinity()) {
			// TODO: This check doesn't work - fix.
			throw new Error("Point is not a scalar multiple of G.");
		}

		return true;
	};




	// ----------------
	// ECCurveFp constructor
	ec.CurveFp = function (q, a, b) {
		this.q = q;
		this.a = this.fromBigInteger(a);
		this.b = this.fromBigInteger(b);
		this.infinity = new ec.PointFp(this, null, null);
	}

	ec.CurveFp.prototype.getQ = function () {
		return this.q;
	};

	ec.CurveFp.prototype.getA = function () {
		return this.a;
	};

	ec.CurveFp.prototype.getB = function () {
		return this.b;
	};

	ec.CurveFp.prototype.equals = function (other) {
		if (other == this) return true;
		return (this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
	};

	ec.CurveFp.prototype.getInfinity = function () {
		return this.infinity;
	};

	ec.CurveFp.prototype.fromBigInteger = function (x) {
		return new ec.FieldElementFp(this.q, x);
	};

	// for now, work with hex strings because they're easier in JS
	// compressed support added by bitaddress.org
	ec.CurveFp.prototype.decodePointHex = function (s) {
		var firstByte = parseInt(s.substr(0, 2), 16);
		switch (firstByte) { // first byte
			case 0:
				return this.infinity;
			case 2: // compressed
			case 3: // compressed
				var yTilde = firstByte & 1;
				var xHex = s.substr(2, s.length - 2);
				var X1 = new BigInteger(xHex, 16);
				return this.decompressPoint(yTilde, X1);
			case 4: // uncompressed
			case 6: // hybrid
			case 7: // hybrid
				var len = (s.length - 2) / 2;
				var xHex = s.substr(2, len);
				var yHex = s.substr(len + 2, len);

				return new ec.PointFp(this,
					this.fromBigInteger(new BigInteger(xHex, 16)),
					this.fromBigInteger(new BigInteger(yHex, 16)));

			default: // unsupported
				return null;
		}
	};

	/*
	* Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
	* Ported to JavaScript by bitaddress.org
	*
	* Number yTilde
	* BigInteger X1
	*/
	ec.CurveFp.prototype.decompressPoint = function (yTilde, X1) {
		var x = this.fromBigInteger(X1);
		var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
		var beta = alpha.sqrt();
		// if we can't find a sqrt we haven't got a point on the curve - run!
		if (beta == null) throw new Error("Invalid point compression");
		var betaValue = beta.toBigInteger();
		var bit0 = betaValue.testBit(0) ? 1 : 0;
		if (bit0 != yTilde) {
			// Use the other root
			beta = this.fromBigInteger(this.getQ().subtract(betaValue));
		}
		return new ec.PointFp(this, x, beta, null, true);
	};


	ec.fromHex = function (s) { return new BigInteger(s, 16); };

	ec.integerToBytes = function (i, len) {
		var bytes = i.toByteArrayUnsigned();
		if (len < bytes.length) {
			bytes = bytes.slice(bytes.length - len);
		} else while (len > bytes.length) {
			bytes.unshift(0);
		}
		return bytes;
	};


	// Named EC curves
	// ----------------
	// X9ECParameters constructor
	ec.X9Parameters = function (curve, g, n, h) {
		this.curve = curve;
		this.g = g;
		this.n = n;
		this.h = h;
	}
	ec.X9Parameters.prototype.getCurve = function () { return this.curve; };
	ec.X9Parameters.prototype.getG = function () { return this.g; };
	ec.X9Parameters.prototype.getN = function () { return this.n; };
	ec.X9Parameters.prototype.getH = function () { return this.h; };

	// secp256k1 is the Curve used by Bitcoin
	ec.secNamedCurves = {
		// used by Bitcoin
		"secp256k1": function () {
			// p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
			var p = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
			var a = BigInteger.ZERO;
			var b = ec.fromHex("7");
			var n = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
			var h = BigInteger.ONE;
			var curve = new ec.CurveFp(p, a, b);
			var G = curve.decodePointHex("04"
					+ "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"
					+ "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");
			return new ec.X9Parameters(curve, G, n, h);
		}
	};

	// secp256k1 called by Bitcoin's ECKEY
	ec.getSECCurveByName = function (name) {
		if (ec.secNamedCurves[name] == undefined) return null;
		return ec.secNamedCurves[name]();
	}
})(exports);

var EllipticCurve = exports.EllipticCurve;//https://raw.github.com/bitcoinjs/bitcoinjs-lib/09e8c6e184d6501a0c2c59d73ca64db5c0d3eb95/src/address.js
// See here for license information: https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE
(function (Bitcoin) {
	Bitcoin.Address = function (bytes) {
		if ("string" == typeof bytes) {
			bytes = Bitcoin.Address.decodeString(bytes);
		}
		this.hash = bytes;
		this.version = Bitcoin.Address.networkVersion;
	};

	Bitcoin.Address.networkVersion = 0x00; // mainnet

	/**
	* Serialize this object as a standard Bitcoin address.
	*
	* Returns the address as a base58-encoded string in the standardized format.
	*/
	Bitcoin.Address.prototype.toString = function () {
		// Get a copy of the hash
		var hash = this.hash.slice(0);

		// Version
		hash.unshift(this.version);
		var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
		var bytes = hash.concat(checksum.slice(0, 4));
		return Bitcoin.Base58.encode(bytes);
	};

	Bitcoin.Address.prototype.getHashBase64 = function () {
		return Crypto.util.bytesToBase64(this.hash);
	};

	/**
	* Parse a Bitcoin address contained in a string.
	*/
	Bitcoin.Address.decodeString = function (string) {
		var bytes = Bitcoin.Base58.decode(string);
		var hash = bytes.slice(0, 21);
		var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });

		if (checksum[0] != bytes[21] ||
				checksum[1] != bytes[22] ||
				checksum[2] != bytes[23] ||
				checksum[3] != bytes[24]) {
			throw "Checksum validation failed!";
		}

		var version = hash.shift();

		if (version != 0) {
			throw "Version " + version + " not supported!";
		}

		return hash;
	};
})(Bitcoin);
//https://raw.github.com/bitcoinjs/bitcoinjs-lib/c952aaeb3ee472e3776655b8ea07299ebed702c7/src/base58.js
// See here for license information: https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE
(function (Bitcoin) {
	Bitcoin.Base58 = {
		alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
		validRegex: /^[1-9A-HJ-NP-Za-km-z]+$/,
		base: BigInteger.valueOf(58),

		/**
		* Convert a byte array to a base58-encoded string.
		*
		* Written by Mike Hearn for BitcoinJ.
		*   Copyright (c) 2011 Google Inc.
		*
		* Ported to JavaScript by Stefan Thomas.
		*/
		encode: function (input) {
			var bi = BigInteger.fromByteArrayUnsigned(input);
			var chars = [];

			while (bi.compareTo(B58.base) >= 0) {
				var mod = bi.mod(B58.base);
				chars.unshift(B58.alphabet[mod.intValue()]);
				bi = bi.subtract(mod).divide(B58.base);
			}
			chars.unshift(B58.alphabet[bi.intValue()]);

			// Convert leading zeros too.
			for (var i = 0; i < input.length; i++) {
				if (input[i] == 0x00) {
					chars.unshift(B58.alphabet[0]);
				} else break;
			}

			return chars.join('');
		},

		/**
		* Convert a base58-encoded string to a byte array.
		*
		* Written by Mike Hearn for BitcoinJ.
		*   Copyright (c) 2011 Google Inc.
		*
		* Ported to JavaScript by Stefan Thomas.
		*/
		decode: function (input) {
			var bi = BigInteger.valueOf(0);
			var leadingZerosNum = 0;
			for (var i = input.length - 1; i >= 0; i--) {
				var alphaIndex = B58.alphabet.indexOf(input[i]);
				if (alphaIndex < 0) {
					throw "Invalid character";
				}
				bi = bi.add(BigInteger.valueOf(alphaIndex)
								.multiply(B58.base.pow(input.length - 1 - i)));

				// This counts leading zero bytes
				if (input[i] == "1") leadingZerosNum++;
				else leadingZerosNum = 0;
			}
			var bytes = bi.toByteArrayUnsigned();

			// Add leading zeros
			while (leadingZerosNum-- > 0) bytes.unshift(0);

			return bytes;
		}
	};

	var B58 = Bitcoin.Base58;
})(Bitcoin);
//https://raw.github.com/pointbiz/bitcoinjs-lib/9b2f94a028a7bc9bed94e0722563e9ff1d8e8db8/src/eckey.js
// See here for license information: https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE
(function (Bitcoin) {
	Bitcoin.ECKey = (function () {
		var ecparams = EllipticCurve.getSECCurveByName("secp256k1");

		var ECKey = function (input) {
			if (input instanceof BigInteger) {
				// Input is a private key value
				this.priv = input;
			} else if (Bitcoin.Util.isArray(input)) {
				// Prepend zero byte to prevent interpretation as negative integer
				this.priv = BigInteger.fromByteArrayUnsigned(input);
			} else if ("string" == typeof input) {
				var bytes = null;
				if (ECKey.isWalletImportFormat(input)) {
					bytes = ECKey.decodeWalletImportFormat(input);
				} else if (ECKey.isCompressedWalletImportFormat(input)) {
					bytes = ECKey.decodeCompressedWalletImportFormat(input);
					this.compressed = true;
				} else if (ECKey.isMiniFormat(input)) {
					bytes = Crypto.SHA256(input, { asBytes: true });
				} else if (ECKey.isHexFormat(input)) {
					bytes = Crypto.util.hexToBytes(input);
				} else if (ECKey.isBase64Format(input)) {
					bytes = Crypto.util.base64ToBytes(input);
				}
				
				if (ECKey.isBase6Format(input)) {
					this.priv = new BigInteger(input, 6);
				} else if (bytes == null || bytes.length != 32) {
					this.priv = null;
				} else {
					// Prepend zero byte to prevent interpretation as negative integer
					this.priv = BigInteger.fromByteArrayUnsigned(bytes);
				}
			} else {
				throw new Error("no plausible constructor behavior");	
			}

			this.compressed = (this.compressed == undefined) ? !!ECKey.compressByDefault : this.compressed;
		};

		ECKey.privateKeyPrefix = 0x80; // mainnet 0x80    testnet 0xEF

		/**
		* Whether public keys should be returned compressed by default.
		*/
		ECKey.compressByDefault = false;

		/**
		* Set whether the public key should be returned compressed or not.
		*/
		ECKey.prototype.setCompressed = function (v) {
			this.compressed = !!v;
			if (this.pubPoint) this.pubPoint.compressed = this.compressed;
			return this;
		};

		/*
		* Return public key as a byte array in DER encoding
		*/
		ECKey.prototype.getPub = function () {
			if (this.compressed) {
				if (this.pubComp) return this.pubComp;
				return this.pubComp = this.getPubPoint().getEncoded(1);
			} else {
				if (this.pubUncomp) return this.pubUncomp;
				return this.pubUncomp = this.getPubPoint().getEncoded(0);
			}
		};

		/**
		* Return public point as ECPoint object.
		*/
		ECKey.prototype.getPubPoint = function () {
			if (!this.pubPoint) {
				this.pubPoint = ecparams.getG().multiply(this.priv);
				this.pubPoint.compressed = this.compressed;
			}
			return this.pubPoint;
		};

		ECKey.prototype.getPubKeyHex = function () {
			if (this.compressed) {
				if (this.pubKeyHexComp) return this.pubKeyHexComp;
				return this.pubKeyHexComp = Crypto.util.bytesToHex(this.getPub()).toString().toUpperCase();
			} else {
				if (this.pubKeyHexUncomp) return this.pubKeyHexUncomp;
				return this.pubKeyHexUncomp = Crypto.util.bytesToHex(this.getPub()).toString().toUpperCase();
			}
		};

		/**
		* Get the pubKeyHash for this key.
		*
		* This is calculated as RIPE160(SHA256([encoded pubkey])) and returned as
		* a byte array.
		*/
		ECKey.prototype.getPubKeyHash = function () {
			if (this.compressed) {
				if (this.pubKeyHashComp) return this.pubKeyHashComp;
				return this.pubKeyHashComp = Bitcoin.Util.sha256ripe160(this.getPub());
			} else {
				if (this.pubKeyHashUncomp) return this.pubKeyHashUncomp;
				return this.pubKeyHashUncomp = Bitcoin.Util.sha256ripe160(this.getPub());
			}
		};

		ECKey.prototype.getBitcoinAddress = function () {
			var hash = this.getPubKeyHash();
			var addr = new Bitcoin.Address(hash);
			return addr.toString();
		};

		/*
		* Takes a public point as a hex string or byte array
		*/
		ECKey.prototype.setPub = function (pub) {
			// byte array
			if (Bitcoin.Util.isArray(pub)) {
				pub = Crypto.util.bytesToHex(pub).toString().toUpperCase();
			}
			var ecPoint = ecparams.getCurve().decodePointHex(pub);
			this.setCompressed(ecPoint.compressed);
			this.pubPoint = ecPoint;
			return this;
		};

		// Sipa Private Key Wallet Import Format 
		ECKey.prototype.getBitcoinWalletImportFormat = function () {
			var bytes = this.getBitcoinPrivateKeyByteArray();
			bytes.unshift(ECKey.privateKeyPrefix); // prepend 0x80 byte
			if (this.compressed) bytes.push(0x01); // append 0x01 byte for compressed format
			var checksum = Crypto.SHA256(Crypto.SHA256(bytes, { asBytes: true }), { asBytes: true });
			bytes = bytes.concat(checksum.slice(0, 4));
			var privWif = Bitcoin.Base58.encode(bytes);
			return privWif;
		};

		// Private Key Hex Format 
		ECKey.prototype.getBitcoinHexFormat = function () {
			return Crypto.util.bytesToHex(this.getBitcoinPrivateKeyByteArray()).toString().toUpperCase();
		};

		// Private Key Base64 Format 
		ECKey.prototype.getBitcoinBase64Format = function () {
			return Crypto.util.bytesToBase64(this.getBitcoinPrivateKeyByteArray());
		};

		ECKey.prototype.getBitcoinPrivateKeyByteArray = function () {
			// Get a copy of private key as a byte array
			var bytes = this.priv.toByteArrayUnsigned();
			// zero pad if private key is less than 32 bytes 
			while (bytes.length < 32) bytes.unshift(0x00);
			return bytes;
		};

		ECKey.prototype.toString = function (format) {
			format = format || "";
			if (format.toString().toLowerCase() == "base64" || format.toString().toLowerCase() == "b64") {
				return this.getBitcoinBase64Format();
			}
			// Wallet Import Format
			else if (format.toString().toLowerCase() == "wif") {
				return this.getBitcoinWalletImportFormat();
			}
			else {
				return this.getBitcoinHexFormat();
			}
		};

		/**
		* Parse a wallet import format private key contained in a string.
		*/
		ECKey.decodeWalletImportFormat = function (privStr) {
			var bytes = Bitcoin.Base58.decode(privStr);
			var hash = bytes.slice(0, 33);
			var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
			if (checksum[0] != bytes[33] ||
						checksum[1] != bytes[34] ||
						checksum[2] != bytes[35] ||
						checksum[3] != bytes[36]) {
				throw "Checksum validation failed!";
			}
			var version = hash.shift();
			if (version != ECKey.privateKeyPrefix) {
				throw "Version " + version + " not supported!";
			}
			return hash;
		};

		/**
		* Parse a compressed wallet import format private key contained in a string.
		*/
		ECKey.decodeCompressedWalletImportFormat = function (privStr) {
			var bytes = Bitcoin.Base58.decode(privStr);
			var hash = bytes.slice(0, 34);
			var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
			if (checksum[0] != bytes[34] ||
						checksum[1] != bytes[35] ||
						checksum[2] != bytes[36] ||
						checksum[3] != bytes[37]) {
				throw "Checksum validation failed!";
			}
			var version = hash.shift();
			if (version != ECKey.privateKeyPrefix) {
				throw "Version " + version + " not supported!";
			}
			hash.pop();
			return hash;
		};

		// 64 characters [0-9A-F]
		ECKey.isHexFormat = function (key) {
			key = key.toString();
			return /^[A-Fa-f0-9]{64}$/.test(key);
		};

		// 51 characters base58, always starts with a '5'
		ECKey.isWalletImportFormat = function (key) {
			key = key.toString();
			return (ECKey.privateKeyPrefix == 0x80) ?
								(/^5[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{50}$/.test(key)) :
								(/^9[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{50}$/.test(key));
		};

		// 52 characters base58
		ECKey.isCompressedWalletImportFormat = function (key) {
			key = key.toString();
			return (ECKey.privateKeyPrefix == 0x80) ?
								(/^[LK][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51}$/.test(key)) :
								(/^c[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51}$/.test(key));
		};

		// 44 characters
		ECKey.isBase64Format = function (key) {
			key = key.toString();
			return (/^[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=+\/]{44}$/.test(key));
		};

		// 99 characters, 1=1, if using dice convert 6 to 0
		ECKey.isBase6Format = function (key) {
			key = key.toString();
			return (/^[012345]{99}$/.test(key));
		};

		// 22, 26 or 30 characters, always starts with an 'S'
		ECKey.isMiniFormat = function (key) {
			key = key.toString();
			var validChars22 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{21}$/.test(key);
			var validChars26 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25}$/.test(key);
			var validChars30 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}$/.test(key);
			var testBytes = Crypto.SHA256(key + "?", { asBytes: true });

			return ((testBytes[0] === 0x00 || testBytes[0] === 0x01) && (validChars22 || validChars26 || validChars30));
		};

		return ECKey;
	})();
})(Bitcoin);//https://raw.github.com/bitcoinjs/bitcoinjs-lib/09e8c6e184d6501a0c2c59d73ca64db5c0d3eb95/src/util.js
// See here for license information: https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE
// Bitcoin utility functions
(function (Bitcoin) {
	Bitcoin.Util = {
		/**
		* Cross-browser compatibility version of Array.isArray.
		*/
		isArray: Array.isArray || function (o) {
			return Object.prototype.toString.call(o) === '[object Array]';
		},
		/**
		* Create an array of a certain length filled with a specific value.
		*/
		makeFilledArray: function (len, val) {
			var array = [];
			var i = 0;
			while (i < len) {
				array[i++] = val;
			}
			return array;
		},
		/**
		* Turn an integer into a "var_int".
		*
		* "var_int" is a variable length integer used by Bitcoin's binary format.
		*
		* Returns a byte array.
		*/
		numToVarInt: function (i) {
			if (i < 0xfd) {
				// unsigned char
				return [i];
			} else if (i <= 1 << 16) {
				// unsigned short (LE)
				return [0xfd, i >>> 8, i & 255];
			} else if (i <= 1 << 32) {
				// unsigned int (LE)
				return [0xfe].concat(Crypto.util.wordsToBytes([i]));
			} else {
				// unsigned long long (LE)
				return [0xff].concat(Crypto.util.wordsToBytes([i >>> 32, i]));
			}
		},
		/**
		* Parse a Bitcoin value byte array, returning a BigInteger.
		*/
		valueToBigInt: function (valueBuffer) {
			if (valueBuffer instanceof BigInteger) return valueBuffer;

			// Prepend zero byte to prevent interpretation as negative integer
			return BigInteger.fromByteArrayUnsigned(valueBuffer);
		},
		/**
		* Format a Bitcoin value as a string.
		*
		* Takes a BigInteger or byte-array and returns that amount of Bitcoins in a
		* nice standard formatting.
		*
		* Examples:
		* 12.3555
		* 0.1234
		* 900.99998888
		* 34.00
		*/
		formatValue: function (valueBuffer) {
			var value = this.valueToBigInt(valueBuffer).toString();
			var integerPart = value.length > 8 ? value.substr(0, value.length - 8) : '0';
			var decimalPart = value.length > 8 ? value.substr(value.length - 8) : value;
			while (decimalPart.length < 8) decimalPart = "0" + decimalPart;
			decimalPart = decimalPart.replace(/0*$/, '');
			while (decimalPart.length < 2) decimalPart += "0";
			return integerPart + "." + decimalPart;
		},
		/**
		* Parse a floating point string as a Bitcoin value.
		*
		* Keep in mind that parsing user input is messy. You should always display
		* the parsed value back to the user to make sure we understood his input
		* correctly.
		*/
		parseValue: function (valueString) {
			// TODO: Detect other number formats (e.g. comma as decimal separator)
			var valueComp = valueString.split('.');
			var integralPart = valueComp[0];
			var fractionalPart = valueComp[1] || "0";
			while (fractionalPart.length < 8) fractionalPart += "0";
			fractionalPart = fractionalPart.replace(/^0+/g, '');
			var value = BigInteger.valueOf(parseInt(integralPart));
			value = value.multiply(BigInteger.valueOf(100000000));
			value = value.add(BigInteger.valueOf(parseInt(fractionalPart)));
			return value;
		},
		/**
		* Calculate RIPEMD160(SHA256(data)).
		*
		* Takes an arbitrary byte array as inputs and returns the hash as a byte
		* array.
		*/
		sha256ripe160: function (data) {
			return Crypto.RIPEMD160(Crypto.SHA256(data, { asBytes: true }), { asBytes: true });
		},
		// double sha256
		dsha256: function (data) {
			return Crypto.SHA256(Crypto.SHA256(data, { asBytes: true }), { asBytes: true });
		}
	};
})(Bitcoin);
},{}],8:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var AES, BlockCipher, G, Global, scrub_vec,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  BlockCipher = require('./algbase').BlockCipher;

  scrub_vec = require('./util').scrub_vec;

  Global = (function() {
    function Global() {
      var i;
      this.SBOX = [];
      this.INV_SBOX = [];
      this.SUB_MIX = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
          _results.push([]);
        }
        return _results;
      })();
      this.INV_SUB_MIX = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
          _results.push([]);
        }
        return _results;
      })();
      this.init();
      this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    }

    Global.prototype.init = function() {
      var d, i, sx, t, x, x2, x4, x8, xi, _i;
      d = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 256; i = ++_i) {
          if (i < 128) {
            _results.push(i << 1);
          } else {
            _results.push((i << 1) ^ 0x11b);
          }
        }
        return _results;
      })();
      x = 0;
      xi = 0;
      for (i = _i = 0; _i < 256; i = ++_i) {
        sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
        this.SBOX[x] = sx;
        this.INV_SBOX[sx] = x;
        x2 = d[x];
        x4 = d[x2];
        x8 = d[x4];
        t = (d[sx] * 0x101) ^ (sx * 0x1010100);
        this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
        this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
        this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
        this.SUB_MIX[3][x] = t;
        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
        this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
        this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
        this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
        this.INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
      return true;
    };

    return Global;

  })();

  G = new Global();

  AES = (function(_super) {
    __extends(AES, _super);

    AES.blockSize = 4 * 4;

    AES.prototype.blockSize = AES.blockSize;

    AES.keySize = 256 / 8;

    AES.prototype.keySize = AES.keySize;

    AES.ivSize = AES.blockSize;

    AES.prototype.ivSize = AES.ivSize;

    function AES(key) {
      this._key = key.clone();
      this._doReset();
    }

    AES.prototype._doReset = function() {
      var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
      keyWords = this._key.words;
      keySize = this._key.sigBytes / 4;
      this._nRounds = keySize + 6;
      ksRows = (this._nRounds + 1) * 4;
      this._keySchedule = [];
      for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {
        this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
      }
      this._invKeySchedule = [];
      for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {
        ksRow = ksRows - invKsRow;
        t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
        this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
      }
      return true;
    };

    AES.prototype.encryptBlock = function(M, offset) {
      if (offset == null) {
        offset = 0;
      }
      return this._doCryptBlock(M, offset, this._keySchedule, G.SUB_MIX, G.SBOX);
    };

    AES.prototype.decryptBlock = function(M, offset) {
      var _ref, _ref1;
      if (offset == null) {
        offset = 0;
      }
      _ref = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref[0], M[offset + 3] = _ref[1];
      this._doCryptBlock(M, offset, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
      return _ref1 = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref1[0], M[offset + 3] = _ref1[1], _ref1;
    };

    AES.prototype.scrub = function() {
      scrub_vec(this._keySchedule);
      scrub_vec(this._invKeySchedule);
      return this._key.scrub();
    };

    AES.prototype._doCryptBlock = function(M, offset, keySchedule, SUB_MIX, SBOX) {
      var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;
      s0 = M[offset] ^ keySchedule[0];
      s1 = M[offset + 1] ^ keySchedule[1];
      s2 = M[offset + 2] ^ keySchedule[2];
      s3 = M[offset + 3] ^ keySchedule[3];
      ksRow = 4;
      for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {
        t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
      t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
      t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
      t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
      M[offset] = t0;
      M[offset + 1] = t1;
      M[offset + 2] = t2;
      return M[offset + 3] = t3;
    };

    return AES;

  })(BlockCipher);

  exports.AES = AES;

}).call(this);

},{"./algbase":9,"./util":28}],9:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var BlockCipher, BufferedBlockAlgorithm, Hasher, StreamCipher, WordArray, util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  util = require('./util');

  BufferedBlockAlgorithm = (function() {
    BufferedBlockAlgorithm.prototype._minBufferSize = 0;

    function BufferedBlockAlgorithm() {
      this.reset();
    }

    BufferedBlockAlgorithm.prototype.reset = function() {
      this._data = new WordArray();
      return this._nDataBytes = 0;
    };

    BufferedBlockAlgorithm.prototype._append = function(data) {
      this._data.concat(data);
      return this._nDataBytes += data.sigBytes;
    };

    BufferedBlockAlgorithm.prototype._process = function(doFlush) {
      var blockSizeBytes, data, dataSigBytes, dataWords, nBlocksReady, nBytesReady, nWordsReady, offset, processedWords, _i, _ref;
      data = this._data;
      dataWords = data.words;
      dataSigBytes = data.sigBytes;
      blockSizeBytes = this.blockSize * 4;
      nBlocksReady = dataSigBytes / blockSizeBytes;
      if (doFlush) {
        nBlocksReady = Math.ceil(nBlocksReady);
      } else {
        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
      }
      nWordsReady = nBlocksReady * this.blockSize;
      nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
      if (nWordsReady) {
        for (offset = _i = 0, _ref = this.blockSize; _ref > 0 ? _i < nWordsReady : _i > nWordsReady; offset = _i += _ref) {
          this._doProcessBlock(dataWords, offset);
        }
        processedWords = dataWords.splice(0, nWordsReady);
        data.sigBytes -= nBytesReady;
      }
      return new WordArray(processedWords, nBytesReady);
    };

    BufferedBlockAlgorithm.prototype.copy_to = function(out) {
      out._data = this._data.clone();
      return out._nDataBytes = this._nDataBytes;
    };

    BufferedBlockAlgorithm.prototype.clone = function() {
      var obj;
      obj = new BufferedBlockAlgorithm();
      this.copy_to(obj);
      return obj;
    };

    return BufferedBlockAlgorithm;

  })();

  Hasher = (function(_super) {
    __extends(Hasher, _super);

    function Hasher() {
      Hasher.__super__.constructor.call(this);
    }

    Hasher.prototype.reset = function() {
      Hasher.__super__.reset.call(this);
      this._doReset();
      return this;
    };

    Hasher.prototype.update = function(messageUpdate) {
      this._append(messageUpdate);
      this._process();
      return this;
    };

    Hasher.prototype.finalize = function(messageUpdate) {
      if (messageUpdate) {
        this._append(messageUpdate);
      }
      return this._doFinalize();
    };

    Hasher.prototype.bufhash = function(input) {
      var out, wa_in, wa_out;
      wa_in = WordArray.from_buffer(input);
      wa_out = this.finalize(wa_in);
      out = wa_out.to_buffer();
      wa_in.scrub();
      wa_out.scrub();
      return out;
    };

    return Hasher;

  })(BufferedBlockAlgorithm);

  exports.BlockCipher = BlockCipher = (function() {
    function BlockCipher(key) {}

    BlockCipher.prototype.encryptBlock = function(M, offset) {};

    return BlockCipher;

  })();

  StreamCipher = (function() {
    function StreamCipher() {}

    StreamCipher.prototype.encryptBlock = function(word_array, dst_offset) {
      var n_words, pad;
      if (dst_offset == null) {
        dst_offset = 0;
      }
      pad = this.get_pad();
      n_words = Math.min(word_array.words.length - dst_offset, this.bsiw);
      word_array.xor(pad, {
        dst_offset: dst_offset,
        n_words: n_words
      });
      pad.scrub();
      return this.bsiw;
    };

    StreamCipher.prototype.encrypt = function(word_array) {
      var i, _i, _ref, _ref1;
      for (i = _i = 0, _ref = word_array.words.length, _ref1 = this.bsiw; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {
        this.encryptBlock(word_array, i);
      }
      return word_array;
    };

    StreamCipher.prototype.bulk_encrypt = function(_arg, cb) {
      var async_args, input, progress_hook, slice_args, what,
        _this = this;
      input = _arg.input, progress_hook = _arg.progress_hook, what = _arg.what;
      slice_args = {
        update: function(lo, hi) {
          var i, _i, _ref, _results;
          _results = [];
          for (i = _i = lo, _ref = _this.bsiw; _ref > 0 ? _i < hi : _i > hi; i = _i += _ref) {
            _results.push(_this.encryptBlock(input, i));
          }
          return _results;
        },
        finalize: function() {
          return input;
        },
        default_n: this.bsiw * 1024
      };
      async_args = {
        progress_hook: progress_hook,
        cb: cb,
        what: what
      };
      return util.bulk(input.sigBytes, slice_args, async_args);
    };

    return StreamCipher;

  })();

  exports.BlockCipher = BlockCipher;

  exports.Hasher = Hasher;

  exports.BufferedBlockAlgorithm = BufferedBlockAlgorithm;

  exports.StreamCipher = StreamCipher;

}).call(this);

},{"./util":28,"./wordarray":29}],10:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var CombineBase, Concat, HMAC, SHA3, SHA512, WordArray, XOR, bulk_sign, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  _ref = require('./hmac'), HMAC = _ref.HMAC, bulk_sign = _ref.bulk_sign;

  SHA512 = require('./sha512').SHA512;

  SHA3 = require('./sha3').SHA3;

  WordArray = require('./wordarray').WordArray;

  CombineBase = (function() {
    function CombineBase() {
      this.hasherBlockSize = this.hashers[0].hasherBlockSize;
      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
      this.reset();
    }

    CombineBase.prototype.reset = function() {
      var h, _i, _len, _ref1;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        h.reset();
      }
      return this;
    };

    CombineBase.prototype.update = function(w) {
      var h, _i, _len, _ref1;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        h.update(w);
      }
      return this;
    };

    CombineBase.prototype.scrub = function() {
      var h, _i, _len, _ref1;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        h.scrub();
      }
      return this;
    };

    CombineBase.prototype.finalize = function(w) {
      var h, hashes, out, _i, _len, _ref1;
      hashes = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.hashers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          h = _ref1[_i];
          _results.push(h.finalize(w));
        }
        return _results;
      }).call(this);
      out = hashes[0];
      _ref1 = hashes.slice(1);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        this._coalesce(out, h);
        h.scrub();
      }
      return out;
    };

    return CombineBase;

  })();

  Concat = (function(_super) {
    __extends(Concat, _super);

    function Concat(key, klasses) {
      var hm, i, klass, subkey, subkeys;
      if (klasses == null) {
        klasses = [SHA512, SHA3];
      }
      subkeys = key.split(klasses.length);
      this.hashers = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = klasses.length; _i < _len; i = ++_i) {
          klass = klasses[i];
          subkey = subkeys[i];
          hm = new HMAC(subkey, klass);
          subkey.scrub();
          _results.push(hm);
        }
        return _results;
      })();
      Concat.__super__.constructor.call(this);
    }

    Concat.get_output_size = function() {
      return SHA512.output_size + SHA3.output_size;
    };

    Concat.prototype._coalesce = function(out, h) {
      return out.concat(h);
    };

    Concat.prototype.get_output_size = function() {
      var h, tot, _i, _len, _ref1;
      tot = 0;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        tot += h.get_output_size();
      }
      return tot;
    };

    Concat.sign = function(_arg) {
      var input, key;
      key = _arg.key, input = _arg.input;
      return (new Concat(key)).finalize(input);
    };

    Concat.bulk_sign = function(args, cb) {
      args.klass = Concat;
      args.what = "HMAC-SHA512-SHA3";
      return bulk_sign(args, cb);
    };

    return Concat;

  })(CombineBase);

  XOR = (function(_super) {
    __extends(XOR, _super);

    function XOR(key, klasses) {
      var klass;
      if (klasses == null) {
        klasses = [SHA512, SHA3];
      }
      this.hashers = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = klasses.length; _i < _len; _i++) {
          klass = klasses[_i];
          _results.push(new HMAC(key, klass));
        }
        return _results;
      })();
      XOR.__super__.constructor.call(this);
    }

    XOR.prototype.reset = function() {
      var h, i, _i, _len, _ref1;
      XOR.__super__.reset.call(this);
      _ref1 = this.hashers;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        h = _ref1[i];
        h.update(new WordArray([i]));
      }
      return this;
    };

    XOR.get_output_size = function() {
      return Math.max(SHA512.output_size, SHA3.output_size);
    };

    XOR.prototype._coalesce = function(out, h) {
      return out.xor(h, {});
    };

    XOR.prototype.get_output_size = function() {
      var h;
      return Math.max.apply(Math, (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.hashers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          h = _ref1[_i];
          _results.push(h.get_output_size());
        }
        return _results;
      }).call(this));
    };

    XOR.sign = function(_arg) {
      var input, key;
      key = _arg.key, input = _arg.input;
      return (new XOR(key)).finalize(input);
    };

    XOR.bulk_sign = function(arg, cb) {
      arg.klass = XOR;
      arg.what = "HMAC-SHA512-XOR-SHA3";
      return bulk_sign(arg, cb);
    };

    return XOR;

  })(CombineBase);

  exports.Concat = Concat;

  exports.XOR = XOR;

}).call(this);

},{"./hmac":15,"./sha3":25,"./sha512":26,"./wordarray":29}],11:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Cipher, Counter, StreamCipher, WordArray, bulk_encrypt, encrypt, iced, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('./wordarray').WordArray;

  StreamCipher = require('./algbase').StreamCipher;

  Counter = (function() {
    Counter.prototype.WORD_MAX = 0xffffffff;

    function Counter(_arg) {
      var i, len, value;
      value = _arg.value, len = _arg.len;
      this._value = value != null ? value.clone() : (len == null ? len = 2 : void 0, new WordArray((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })()));
    }

    Counter.prototype.inc = function() {
      var go, i;
      go = true;
      i = this._value.words.length - 1;
      while (go && i >= 0) {
        if ((++this._value.words[i]) > Counter.WORD_MAX) {
          this._value.words[i] = 0;
        } else {
          go = false;
        }
        i--;
      }
      return this;
    };

    Counter.prototype.inc_le = function() {
      var go, i;
      go = true;
      i = 0;
      while (go && i < this._value.words.length) {
        if ((++this._value.words[i]) > Counter.WORD_MAX) {
          this._value.words[i] = 0;
        } else {
          go = false;
        }
        i++;
      }
      return this;
    };

    Counter.prototype.get = function() {
      return this._value;
    };

    Counter.prototype.copy = function() {
      return this._value.clone();
    };

    return Counter;

  })();

  Cipher = (function(_super) {
    __extends(Cipher, _super);

    function Cipher(_arg) {
      this.block_cipher = _arg.block_cipher, this.iv = _arg.iv;
      Cipher.__super__.constructor.call(this);
      this.bsiw = this.block_cipher.blockSize / 4;
      if (!(this.iv.sigBytes === this.block_cipher.blockSize)) {
        throw new Error("IV is wrong length (" + this.iv.sigBytes + ")");
      }
      this.ctr = new Counter({
        value: this.iv
      });
    }

    Cipher.prototype.scrub = function() {
      return this.block_cipher.scrub();
    };

    Cipher.prototype.get_pad = function() {
      var pad;
      pad = this.ctr.copy();
      this.ctr.inc();
      this.block_cipher.encryptBlock(pad.words);
      return pad;
    };

    return Cipher;

  })(StreamCipher);

  encrypt = function(_arg) {
    var block_cipher, cipher, input, iv, ret;
    block_cipher = _arg.block_cipher, iv = _arg.iv, input = _arg.input;
    cipher = new Cipher({
      block_cipher: block_cipher,
      iv: iv
    });
    ret = cipher.encrypt(input);
    cipher.scrub();
    return ret;
  };

  bulk_encrypt = function(_arg, cb) {
    var block_cipher, cipher, input, iv, progress_hook, ret, what, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    block_cipher = _arg.block_cipher, iv = _arg.iv, input = _arg.input, progress_hook = _arg.progress_hook, what = _arg.what;
    cipher = new Cipher({
      block_cipher: block_cipher,
      iv: iv
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/ctr.iced",
        funcname: "bulk_encrypt"
      });
      cipher.bulk_encrypt({
        input: input,
        progress_hook: progress_hook,
        what: what
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return ret = arguments[0];
          };
        })(),
        lineno: 121
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb(ret);
    });
  };

  exports.Counter = Counter;

  exports.Cipher = Cipher;

  exports.encrypt = encrypt;

  exports.bulk_encrypt = bulk_encrypt;

}).call(this);

},{"./algbase":9,"./wordarray":29,"iced-coffee-script/lib/coffee-script/iced":5}],12:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var AES, Base, Concat, Decryptor, SHA512, Salsa20, TwoFish, V, WordArray, ctr, decrypt, iced, make_esc, salsa20, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('./wordarray').WordArray;

  salsa20 = require('./salsa20');

  AES = require('./aes').AES;

  TwoFish = require('./twofish').TwoFish;

  ctr = require('./ctr');

  Concat = require('./combine').Concat;

  SHA512 = require('./sha512').SHA512;

  Salsa20 = require('./salsa20').Salsa20;

  _ref = require('./enc'), Base = _ref.Base, V = _ref.V;

  make_esc = require('iced-error').make_esc;

  Decryptor = (function(_super) {
    __extends(Decryptor, _super);

    function Decryptor(_arg) {
      var enc, key;
      key = _arg.key, enc = _arg.enc;
      Decryptor.__super__.constructor.call(this, {
        key: key
      });
      if (enc != null) {
        this.key = enc.key;
        this.derived_keys = enc.derived_keys;
      }
    }

    Decryptor.prototype.read_header = function(cb) {
      var err, wa;
      err = (wa = this.ct.unshift(2)) == null ? new Error("Ciphertext underrun in header") : (this.version = V[wa.words[1]]) == null ? new Error("bad header; couldn't find a good version (got " + wa.words[1] + ")") : wa.words[0] !== this.version.header[0] ? new Error("Bad header: unrecognized magic value") : null;
      return cb(err);
    };

    Decryptor.prototype.verify_sig = function(key, cb) {
      var computed, err, received, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        if ((received = _this.ct.unshift(Concat.get_output_size() / 4)) == null) {
          return __iced_k(err = new Error("Ciphertext underrun in signature"));
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/dec.iced",
              funcname: "Decryptor.verify_sig"
            });
            _this.sign({
              input: _this.ct,
              key: key,
              salt: _this.salt
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return computed = arguments[1];
                };
              })(),
              lineno: 63
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k(err = err != null ? err : received.equal(computed) ? null : new Error('Signature mismatch or bad decryption key'));
          });
        }
      })(function() {
        return cb(err);
      });
    };

    Decryptor.prototype.unshift_iv = function(n_bytes, which, cb) {
      var err, iv;
      err = (iv = this.ct.unshift(n_bytes / 4)) != null ? null : new Error("Ciphertext underrun in " + which);
      return cb(err, iv);
    };

    Decryptor.prototype.read_salt = function(cb) {
      var err;
      err = (this.salt = this.ct.unshift(this.version.salt_size / 4)) == null ? new Error("Ciphertext underrrun in read_salt") : null;
      return cb(err);
    };

    Decryptor.prototype.generate_keys = function(_arg, cb) {
      var err, keys, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/dec.iced",
          funcname: "Decryptor.generate_keys"
        });
        _this.kdf({
          salt: _this.salt,
          progress_hook: progress_hook
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return keys = arguments[1];
            };
          })(),
          lineno: 114
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(err, keys);
      });
    };

    Decryptor.prototype.run = function(_arg, cb) {
      var ct1, ct2, data, esc, iv, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, progress_hook = _arg.progress_hook;
      esc = make_esc(cb, "Decryptor::run");
      this.ct = WordArray.from_buffer(data);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/dec.iced",
          funcname: "Decryptor.run"
        });
        _this.read_header(esc(__iced_deferrals.defer({
          lineno: 141
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/dec.iced",
            funcname: "Decryptor.run"
          });
          _this.read_salt(esc(__iced_deferrals.defer({
            lineno: 142
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/dec.iced",
              funcname: "Decryptor.run"
            });
            _this.generate_keys({
              progress_hook: progress_hook
            }, esc(__iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  return __slot_1.keys = arguments[0];
                };
              })(_this),
              lineno: 143
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/dec.iced",
                funcname: "Decryptor.run"
              });
              _this.verify_sig(_this.keys.hmac, esc(__iced_deferrals.defer({
                lineno: 144
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/dec.iced",
                  funcname: "Decryptor.run"
                });
                _this.unshift_iv(AES.ivSize, "AES", esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return iv = arguments[0];
                    };
                  })(),
                  lineno: 145
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/dec.iced",
                    funcname: "Decryptor.run"
                  });
                  _this.run_aes({
                    iv: iv,
                    input: _this.ct,
                    key: _this.keys.aes,
                    progress_hook: progress_hook
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return ct2 = arguments[0];
                      };
                    })(),
                    lineno: 146
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/dec.iced",
                      funcname: "Decryptor.run"
                    });
                    _this.unshift_iv(TwoFish.ivSize, "2fish", esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return iv = arguments[0];
                        };
                      })(),
                      lineno: 147
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "src/dec.iced",
                        funcname: "Decryptor.run"
                      });
                      _this.run_twofish({
                        iv: iv,
                        input: _this.ct,
                        key: _this.keys.twofish,
                        progress_hook: progress_hook
                      }, esc(__iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return ct1 = arguments[0];
                          };
                        })(),
                        lineno: 148
                      })));
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "src/dec.iced",
                          funcname: "Decryptor.run"
                        });
                        _this.unshift_iv(Salsa20.ivSize, "Salsa", esc(__iced_deferrals.defer({
                          assign_fn: (function() {
                            return function() {
                              return iv = arguments[0];
                            };
                          })(),
                          lineno: 149
                        })));
                        __iced_deferrals._fulfill();
                      })(function() {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "src/dec.iced",
                            funcname: "Decryptor.run"
                          });
                          _this.run_salsa20({
                            iv: iv,
                            input: _this.ct,
                            key: _this.keys.salsa20,
                            output_iv: false,
                            progress_hook: progress_hook
                          }, esc(__iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return pt = arguments[0];
                              };
                            })(),
                            lineno: 150
                          })));
                          __iced_deferrals._fulfill();
                        })(function() {
                          return cb(null, pt.to_buffer());
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    };

    return Decryptor;

  })(Base);

  decrypt = function(_arg, cb) {
    var data, dec, err, key, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, data = _arg.data, progress_hook = _arg.progress_hook;
    dec = new Decryptor({
      key: key
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/dec.iced",
        funcname: "decrypt"
      });
      dec.run({
        data: data,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return pt = arguments[1];
          };
        })(),
        lineno: 168
      }));
      __iced_deferrals._fulfill();
    })(function() {
      dec.scrub();
      return cb(err, pt);
    });
  };

  exports.Decryptor = Decryptor;

  exports.decrypt = decrypt;

}).call(this);

},{"./aes":8,"./combine":10,"./ctr":11,"./enc":14,"./salsa20":20,"./sha512":26,"./twofish":27,"./wordarray":29,"iced-coffee-script/lib/coffee-script/iced":5,"iced-error":30}],13:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ADRBG, DRBG, Lock, WordArray, XOR, hmac, iced, sha3, sha512, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  hmac = require('./hmac');

  XOR = require('./combine').XOR;

  sha512 = require('./sha512');

  sha3 = require('./sha3');

  WordArray = require('./wordarray').WordArray;

  Lock = require('./lock').Lock;

  DRBG = (function() {
    function DRBG(entropy, personalization_string, hmac_func) {
      this.hmac = hmac_func || hmac.sign;
      this.security_strength = 256;
      entropy = this.check_entropy(entropy);
      personalization_string || (personalization_string = new WordArray([]));
      this._instantiate(entropy, personalization_string);
    }

    DRBG.prototype.check_entropy = function(entropy, reseed) {
      if (reseed == null) {
        reseed = false;
      }
      if ((entropy.sigBytes * 8 * 2) < ((reseed ? 2 : 3) * this.security_strength)) {
        throw new Error("entropy must be at least " + (1.5 * this.security_strength) + " bits.");
      }
      return entropy;
    };

    DRBG.prototype._hmac = function(key, input) {
      return this.hmac({
        key: key,
        input: input
      });
    };

    DRBG.prototype._update = function(provided_data) {
      var V, V_in;
      V = new WordArray([0], 1);
      if (provided_data != null) {
        V = V.concat(provided_data);
      }
      V_in = this.V.clone().concat(V);
      this.K = this._hmac(this.K, V_in);
      V_in.scrub();
      V.scrub();
      this.V = this._hmac(this.K, this.V);
      if (provided_data != null) {
        V_in = this.V.clone().concat(new WordArray([1 << 24], 1)).concat(provided_data);
        this.K = this._hmac(this.K, V_in);
        V_in.scrub();
        this.V = this._hmac(this.K, this.V);
      }
      return provided_data != null ? provided_data.scrub() : void 0;
    };

    DRBG.prototype._instantiate = function(entropy, personalization_string) {
      var i, n, seed_material;
      seed_material = entropy.concat(personalization_string);
      n = 64;
      this.K = WordArray.from_buffer(new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })()));
      this.V = WordArray.from_buffer(new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          _results.push(1);
        }
        return _results;
      })()));
      this._update(seed_material);
      entropy.scrub();
      return this.reseed_counter = 1;
    };

    DRBG.prototype.reseed = function(entropy) {
      this._update(this.check_entropy(entropy, true));
      return this.reseed_counter = 1;
    };

    DRBG.prototype.generate = function(num_bytes) {
      var i, tmp, _ref;
      if ((num_bytes * 8) > 7500) {
        throw new Error("generate cannot generate > 7500 bits in 1 call.");
      }
      if (this.reseed_counter >= 10000) {
        throw new Error("Need a reseed!");
      }
      tmp = [];
      i = 0;
      while ((tmp.length === 0) || (tmp.length * tmp[0].length * 4) < num_bytes) {
        this.V = this._hmac(this.K, this.V);
        tmp.push(this.V.words);
      }
      this._update();
      this.reseed_counter += 1;
      return (new WordArray((_ref = []).concat.apply(_ref, tmp))).truncate(num_bytes);
    };

    return DRBG;

  })();

  ADRBG = (function() {
    function ADRBG(gen_seed, hmac) {
      this.gen_seed = gen_seed;
      this.hmac = hmac;
      this.drbg = null;
      this.lock = new Lock();
    }

    ADRBG.prototype.generate = function(n, cb) {
      var ret, seed, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/drbg.iced",
          funcname: "ADRBG.generate"
        });
        _this.lock.acquire(__iced_deferrals.defer({
          lineno: 148
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (_this.drbg == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/drbg.iced",
                funcname: "ADRBG.generate"
              });
              _this.gen_seed(256, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return seed = arguments[0];
                  };
                })(),
                lineno: 150
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(_this.drbg = new DRBG(seed, null, _this.hmac));
            });
          } else {
            return __iced_k();
          }
        })(function() {
          (function(__iced_k) {
            if (_this.drbg.reseed_counter > 100) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/drbg.iced",
                  funcname: "ADRBG.generate"
                });
                _this.gen_seed(256, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return seed = arguments[0];
                    };
                  })(),
                  lineno: 153
                }));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(_this.drbg.reseed(seed));
              });
            } else {
              return __iced_k();
            }
          })(function() {
            ret = _this.drbg.generate(n);
            _this.lock.release();
            return cb(ret);
          });
        });
      });
    };

    return ADRBG;

  })();

  exports.DRBG = DRBG;

  exports.ADRBG = ADRBG;

}).call(this);

},{"./combine":10,"./hmac":15,"./lock":16,"./sha3":25,"./sha512":26,"./wordarray":29,"__browserify_Buffer":3,"iced-coffee-script/lib/coffee-script/iced":5}],14:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var AES, Base, Concat, Encryptor, HMAC_SHA256, PBKDF2, SHA512, Scrypt, TwoFish, V, WordArray, XOR, ctr, encrypt, iced, make_esc, prng, salsa20, util, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('./wordarray').WordArray;

  salsa20 = require('./salsa20');

  AES = require('./aes').AES;

  TwoFish = require('./twofish').TwoFish;

  ctr = require('./ctr');

  _ref = require('./combine'), XOR = _ref.XOR, Concat = _ref.Concat;

  SHA512 = require('./sha512').SHA512;

  PBKDF2 = require('./pbkdf2').PBKDF2;

  Scrypt = require('./scrypt').Scrypt;

  util = require('./util');

  prng = require('./prng');

  make_esc = require('iced-error').make_esc;

  HMAC_SHA256 = require('./hmac').HMAC_SHA256;

  V = {
    "1": {
      header: [0x1c94d7de, 1],
      salt_size: 8,
      xsalsa20_rev: true,
      kdf: {
        klass: PBKDF2,
        opts: {
          c: 1024,
          klass: XOR
        }
      },
      hmac_key_size: 768 / 8
    },
    "2": {
      header: [0x1c94d7de, 2],
      salt_size: 16,
      xsalsa20_rev: true,
      kdf: {
        klass: Scrypt,
        opts: {
          c: 64,
          klass: XOR,
          N: 12,
          r: 8,
          p: 1
        }
      },
      hmac_key_size: 768 / 8
    },
    "3": {
      header: [0x1c94d7de, 3],
      salt_size: 16,
      xsalsa20_rev: false,
      kdf: {
        klass: Scrypt,
        opts: {
          c: 1,
          klass: HMAC_SHA256,
          N: 15,
          r: 8,
          p: 1
        }
      },
      hmac_key_size: 768 / 8
    }
  };

  Base = (function() {
    function Base(_arg) {
      var key, version;
      key = _arg.key, version = _arg.version;
      this.version = V[version != null ? version : 1];
      if (this.version == null) {
        throw new Error("unknown version: " + version);
      }
      this.set_key(key);
      this.derived_keys = {};
    }

    Base.prototype.kdf = function(_arg, cb) {
      var args, dkLen, end, extra_keymaterial, i, k, key, keys, len, lens, order, progress_hook, raw, salt, salt_hex, v, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.kdf"
        });
        _this._check_scrubbed(_this.key, "in KDF", cb, __iced_deferrals.defer({
          lineno: 90
        }));
        __iced_deferrals._fulfill();
      })(function() {
        salt_hex = salt.to_hex();
        key = _this.key.clone();
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.kdf"
          });
          _this._check_scrubbed(key, "KDF", cb, __iced_deferrals.defer({
            lineno: 98
          }));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            if ((keys = _this.derived_keys[salt_hex]) == null) {
              _this._kdf = new _this.version.kdf.klass(_this.version.kdf.opts);
              lens = {
                hmac: _this.version.hmac_key_size,
                aes: AES.keySize,
                twofish: TwoFish.keySize,
                salsa20: salsa20.Salsa20.keySize
              };
              order = ['hmac', 'aes', 'twofish', 'salsa20'];
              dkLen = extra_keymaterial || 0;
              for (k in lens) {
                v = lens[k];
                dkLen += v;
              }
              args = {
                dkLen: dkLen,
                key: key,
                progress_hook: progress_hook,
                salt: salt
              };
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/enc.iced",
                  funcname: "Base.kdf"
                });
                _this._kdf.run(args, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return raw = arguments[0];
                    };
                  })(),
                  lineno: 117
                }));
                __iced_deferrals._fulfill();
              })(function() {
                var _i, _len;
                keys = {};
                i = 0;
                for (_i = 0, _len = order.length; _i < _len; _i++) {
                  k = order[_i];
                  v = lens[k];
                  len = v / 4;
                  end = i + len;
                  keys[k] = new WordArray(raw.words.slice(i, end));
                  i = end;
                }
                keys.extra = (new WordArray(raw.words.slice(end))).to_buffer();
                return __iced_k(_this.derived_keys[salt_hex] = keys);
              });
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(null, keys);
          });
        });
      });
    };

    Base.prototype.set_key = function(key) {
      var wakey;
      if (key != null) {
        wakey = WordArray.from_buffer(key);
        if (!this.key || !this.key.equal(wakey)) {
          this.scrub();
          return this.key = wakey;
        }
      } else {
        return this.scrub();
      }
    };

    Base.prototype._check_scrubbed = function(key, where, ecb, okcb) {
      if ((key != null) && !key.is_scrubbed()) {
        return okcb();
      } else {
        return ecb(new Error("" + where + ": Failed due to scrubbed key!"), null);
      }
    };

    Base.prototype.sign = function(_arg, cb) {
      var input, key, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, salt = _arg.salt, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.sign"
        });
        _this._check_scrubbed(key, "HMAC", cb, __iced_deferrals.defer({
          lineno: 175
        }));
        __iced_deferrals._fulfill();
      })(function() {
        input = (new WordArray(_this.version.header)).concat(salt).concat(input);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.sign"
          });
          Concat.bulk_sign({
            key: key,
            input: input,
            progress_hook: progress_hook
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return out = arguments[0];
              };
            })(),
            lineno: 177
          }));
          __iced_deferrals._fulfill();
        })(function() {
          input.scrub();
          return cb(null, out);
        });
      });
    };

    Base.prototype.run_salsa20 = function(_arg, cb) {
      var args, ct, input, iv, key, output_iv, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, iv = _arg.iv, output_iv = _arg.output_iv, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.run_salsa20"
        });
        _this._check_scrubbed(key, "Salsa20", cb, __iced_deferrals.defer({
          lineno: 193
        }));
        __iced_deferrals._fulfill();
      })(function() {
        args = {
          input: input,
          progress_hook: progress_hook,
          key: key,
          iv: iv
        };
        if (_this.version.xsalsa20_rev) {
          args.key = key.clone().endian_reverse();
          args.iv = iv.clone().endian_reverse();
        }
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.run_salsa20"
          });
          salsa20.bulk_encrypt(args, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ct = arguments[0];
              };
            })(),
            lineno: 205
          }));
          __iced_deferrals._fulfill();
        })(function() {
          if (output_iv) {
            ct = iv.clone().concat(ct);
          }
          if (_this.version.xsalsa20_rev) {
            args.key.scrub();
            args.iv.scrub();
          }
          return cb(null, ct);
        });
      });
    };

    Base.prototype.run_twofish = function(_arg, cb) {
      var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.run_twofish"
        });
        _this._check_scrubbed(key, "TwoFish", cb, __iced_deferrals.defer({
          lineno: 228
        }));
        __iced_deferrals._fulfill();
      })(function() {
        block_cipher = new TwoFish(key);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.run_twofish"
          });
          ctr.bulk_encrypt({
            block_cipher: block_cipher,
            iv: iv,
            input: input,
            progress_hook: progress_hook,
            what: "twofish"
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ct = arguments[0];
              };
            })(),
            lineno: 230
          }));
          __iced_deferrals._fulfill();
        })(function() {
          block_cipher.scrub();
          return cb(null, iv.clone().concat(ct));
        });
      });
    };

    Base.prototype.run_aes = function(_arg, cb) {
      var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.run_aes"
        });
        _this._check_scrubbed(key, "AES", cb, __iced_deferrals.defer({
          lineno: 245
        }));
        __iced_deferrals._fulfill();
      })(function() {
        block_cipher = new AES(key);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.run_aes"
          });
          ctr.bulk_encrypt({
            block_cipher: block_cipher,
            iv: iv,
            input: input,
            progress_hook: progress_hook,
            what: "aes"
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ct = arguments[0];
              };
            })(),
            lineno: 247
          }));
          __iced_deferrals._fulfill();
        })(function() {
          block_cipher.scrub();
          return cb(null, iv.clone().concat(ct));
        });
      });
    };

    Base.prototype.scrub = function() {
      var key, key_ring, salt, _i, _len, _ref1;
      if (this.key != null) {
        this.key.scrub();
      }
      if (this.derived_keys != null) {
        _ref1 = this.derived_keys;
        for (salt in _ref1) {
          key_ring = _ref1[salt];
          for (_i = 0, _len = key_ring.length; _i < _len; _i++) {
            key = key_ring[_i];
            key.scrub();
          }
        }
      }
      this.derived_keys = {};
      if (this.salt != null) {
        this.salt.scrub();
      }
      this.salt = null;
      return this.key = null;
    };

    return Base;

  })();

  Encryptor = (function(_super) {
    __extends(Encryptor, _super);

    function Encryptor(_arg) {
      var key, rng, version;
      key = _arg.key, rng = _arg.rng, version = _arg.version;
      Encryptor.__super__.constructor.call(this, {
        key: key,
        version: version
      });
      this.rng = rng || prng.generate;
    }

    Encryptor.prototype.pick_random_ivs = function(_arg, cb) {
      var iv_lens, ivs, k, progress_hook, v, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      progress_hook = _arg.progress_hook;
      iv_lens = {
        aes: AES.ivSize,
        twofish: TwoFish.ivSize,
        salsa20: salsa20.Salsa20.ivSize
      };
      ivs = {};
      (function(__iced_k) {
        var _i, _k, _keys, _ref1, _results, _while;
        _ref1 = iv_lens;
        _keys = (function() {
          var _results1;
          _results1 = [];
          for (_k in _ref1) {
            _results1.push(_k);
          }
          return _results1;
        })();
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _keys.length)) {
            return _break();
          } else {
            k = _keys[_i];
            v = _ref1[k];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/enc.iced",
                funcname: "Encryptor.pick_random_ivs"
              });
              _this.rng(v, __iced_deferrals.defer({
                assign_fn: (function(__slot_1, __slot_2) {
                  return function() {
                    return __slot_1[__slot_2] = arguments[0];
                  };
                })(ivs, k),
                lineno: 349
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(ivs);
      });
    };

    Encryptor.prototype.resalt = function(_arg, cb) {
      var err, extra_keymaterial, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;
      err = null;
      (function(__iced_k) {
        if (salt == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/enc.iced",
              funcname: "Encryptor.resalt"
            });
            _this.rng(_this.version.salt_size, __iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  return __slot_1.salt = arguments[0];
                };
              })(_this),
              lineno: 365
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k(salt.length !== _this.version.salt_size ? err = new Error("Need a salt of exactly " + _this.version.salt_size + " bytes (got " + salt.length + ")") : _this.salt = WordArray.alloc(salt));
        }
      })(function() {
        (function(__iced_k) {
          if (err == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/enc.iced",
                funcname: "Encryptor.resalt"
              });
              _this.kdf({
                extra_keymaterial: extra_keymaterial,
                progress_hook: progress_hook,
                salt: _this.salt
              }, __iced_deferrals.defer({
                assign_fn: (function(__slot_1) {
                  return function() {
                    err = arguments[0];
                    return __slot_1.keys = arguments[1];
                  };
                })(_this),
                lineno: 371
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err, _this.keys);
        });
      });
    };

    Encryptor.prototype.run = function(_arg, cb) {
      var ct1, ct2, ct3, data, esc, extra_keymaterial, ivs, progress_hook, pt, ret, salt, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, salt = _arg.salt, extra_keymaterial = _arg.extra_keymaterial, progress_hook = _arg.progress_hook;
      esc = make_esc(cb, "Encryptor::run");
      (function(__iced_k) {
        if ((salt != null) || (_this.salt == null)) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/enc.iced",
              funcname: "Encryptor.run"
            });
            _this.resalt({
              salt: salt,
              extra_keymaterial: extra_keymaterial,
              progress_hook: progress_hook
            }, esc(__iced_deferrals.defer({
              lineno: 402
            })));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Encryptor.run"
          });
          _this.pick_random_ivs({
            progress_hook: progress_hook
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ivs = arguments[0];
              };
            })(),
            lineno: 403
          }));
          __iced_deferrals._fulfill();
        })(function() {
          pt = WordArray.from_buffer(data);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/enc.iced",
              funcname: "Encryptor.run"
            });
            _this.run_salsa20({
              input: pt,
              key: _this.keys.salsa20,
              progress_hook: progress_hook,
              iv: ivs.salsa20,
              output_iv: true
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return ct1 = arguments[0];
                };
              })(),
              lineno: 405
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/enc.iced",
                funcname: "Encryptor.run"
              });
              _this.run_twofish({
                input: ct1,
                key: _this.keys.twofish,
                progress_hook: progress_hook,
                iv: ivs.twofish
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return ct2 = arguments[0];
                  };
                })(),
                lineno: 406
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/enc.iced",
                  funcname: "Encryptor.run"
                });
                _this.run_aes({
                  input: ct2,
                  key: _this.keys.aes,
                  progress_hook: progress_hook,
                  iv: ivs.aes
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return ct3 = arguments[0];
                    };
                  })(),
                  lineno: 407
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/enc.iced",
                    funcname: "Encryptor.run"
                  });
                  _this.sign({
                    input: ct3,
                    key: _this.keys.hmac,
                    progress_hook: progress_hook,
                    salt: _this.salt
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return sig = arguments[0];
                      };
                    })(),
                    lineno: 408
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  ret = (new WordArray(_this.version.header)).concat(_this.salt).concat(sig).concat(ct3).to_buffer();
                  util.scrub_buffer(data);
                  return cb(null, ret);
                });
              });
            });
          });
        });
      });
    };

    return Encryptor;

  })(Base);

  encrypt = function(_arg, cb) {
    var data, enc, err, key, progress_hook, ret, rng, version, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, data = _arg.data, rng = _arg.rng, progress_hook = _arg.progress_hook, version = _arg.version;
    enc = new Encryptor({
      key: key,
      rng: rng,
      version: version
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/enc.iced",
        funcname: "encrypt"
      });
      enc.run({
        data: data,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return ret = arguments[1];
          };
        })(),
        lineno: 436
      }));
      __iced_deferrals._fulfill();
    })(function() {
      enc.scrub();
      return cb(err, ret);
    });
  };

  exports.V = V;

  exports.encrypt = encrypt;

  exports.Base = Base;

  exports.Encryptor = Encryptor;

}).call(this);

},{"./aes":8,"./combine":10,"./ctr":11,"./hmac":15,"./pbkdf2":18,"./prng":19,"./salsa20":20,"./scrypt":21,"./sha512":26,"./twofish":27,"./util":28,"./wordarray":29,"iced-coffee-script/lib/coffee-script/iced":5,"iced-error":30}],15:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var HMAC, HMAC_SHA256, SHA256, SHA512, bulk_sign, iced, sign, util, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  SHA512 = require('./sha512').SHA512;

  SHA256 = require('./sha256').SHA256;

  util = require('./util');

  HMAC = (function() {
    HMAC.outputSize = 512 / 8;

    HMAC.prototype.outputSize = HMAC.outputSize;

    function HMAC(key, klass) {
      var i, _i, _ref;
      if (klass == null) {
        klass = SHA512;
      }
      this.key = key.clone();
      this.hasher = new klass();
      this.hasherBlockSize = this.hasher.blockSize;
      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
      if (this.key.sigBytes > this.hasherBlockSizeBytes) {
        this.key = this.hasher.finalize(this.key);
      }
      this.key.clamp();
      this._oKey = this.key.clone();
      this._iKey = this.key.clone();
      for (i = _i = 0, _ref = this.hasherBlockSize; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this._oKey.words[i] ^= 0x5c5c5c5c;
        this._iKey.words[i] ^= 0x36363636;
      }
      this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
      this.reset();
    }

    HMAC.prototype.get_output_size = function() {
      return this.hasher.output_size;
    };

    HMAC.prototype.reset = function() {
      return this.hasher.reset().update(this._iKey);
    };

    HMAC.prototype.update = function(wa) {
      this.hasher.update(wa);
      return this;
    };

    HMAC.prototype.finalize = function(wa) {
      var innerHash, innerHash2, out;
      innerHash = this.hasher.finalize(wa);
      this.hasher.reset();
      innerHash2 = this._oKey.clone().concat(innerHash);
      out = this.hasher.finalize(innerHash2);
      innerHash.scrub();
      innerHash2.scrub();
      return out;
    };

    HMAC.prototype.scrub = function() {
      this.key.scrub();
      this._iKey.scrub();
      return this._oKey.scrub();
    };

    return HMAC;

  })();

  sign = function(_arg) {
    var eng, hash_class, input, key, out;
    key = _arg.key, input = _arg.input, hash_class = _arg.hash_class;
    eng = new HMAC(key, hash_class);
    out = eng.finalize(input.clamp());
    eng.scrub();
    return out;
  };

  bulk_sign = function(_arg, cb) {
    var eng, input, key, klass, progress_hook, res, slice_args, what, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, input = _arg.input, progress_hook = _arg.progress_hook, klass = _arg.klass, what = _arg.what;
    klass || (klass = HMAC);
    what || (what = "hmac_sha512");
    eng = new klass(key);
    input.clamp();
    slice_args = {
      update: function(lo, hi) {
        return eng.update(input.slice(lo, hi));
      },
      finalize: function() {
        return eng.finalize();
      },
      default_n: eng.hasherBlockSize * 1000
    };
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/hmac.iced",
        funcname: "bulk_sign"
      });
      util.bulk(input.sigBytes, slice_args, {
        what: what,
        progress_hook: progress_hook,
        cb: __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return res = arguments[0];
            };
          })(),
          lineno: 137
        })
      });
      __iced_deferrals._fulfill();
    })(function() {
      eng.scrub();
      return cb(res);
    });
  };

  exports.HMAC_SHA256 = HMAC_SHA256 = (function(_super) {
    __extends(HMAC_SHA256, _super);

    function HMAC_SHA256(key) {
      HMAC_SHA256.__super__.constructor.call(this, key, SHA256);
    }

    return HMAC_SHA256;

  })(HMAC);

  exports.HMAC = HMAC;

  exports.sign = sign;

  exports.bulk_sign = bulk_sign;

}).call(this);

},{"./sha256":24,"./sha512":26,"./util":28,"iced-coffee-script/lib/coffee-script/iced":5}],16:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Lock, NamedLock, Table, iced, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  Lock = (function() {
    function Lock() {
      this._open = true;
      this._waiters = [];
    }

    Lock.prototype.acquire = function(cb) {
      if (this._open) {
        this._open = false;
        return cb();
      } else {
        return this._waiters.push(cb);
      }
    };

    Lock.prototype.release = function() {
      var w;
      if (this._waiters.length) {
        w = this._waiters.shift();
        return w();
      } else {
        return this._open = true;
      }
    };

    Lock.prototype.open = function() {
      return this._open;
    };

    return Lock;

  })();

  NamedLock = (function(_super) {
    __extends(NamedLock, _super);

    function NamedLock(tab, name) {
      this.tab = tab;
      this.name = name;
      NamedLock.__super__.constructor.call(this);
      this.refs = 0;
    }

    NamedLock.prototype.incref = function() {
      return ++this.refs;
    };

    NamedLock.prototype.decref = function() {
      return --this.refs;
    };

    NamedLock.prototype.release = function() {
      NamedLock.__super__.release.call(this);
      if (this.decref() === 0) {
        return delete this.tab[this.name];
      }
    };

    return NamedLock;

  })(Lock);

  Table = (function() {
    function Table() {
      this.locks = {};
    }

    Table.prototype.create = function(name) {
      var l;
      l = new NamedLock(this, name);
      return this.locks[name] = l;
    };

    Table.prototype.acquire = function(name, cb, wait) {
      var l, was_open, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      l = this.locks[name] || this.create(name);
      was_open = l._open;
      l.incref();
      (function(__iced_k) {
        if (wait || l._open) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/lock.iced",
              funcname: "Table.acquire"
            });
            l.acquire(__iced_deferrals.defer({
              lineno: 68
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k(l = null);
        }
      })(function() {
        return cb(l, was_open);
      });
    };

    Table.prototype.lookup = function(name) {
      return this.locks[name];
    };

    return Table;

  })();

  exports.Lock = Lock;

  exports.Table = Table;

}).call(this);

},{"iced-coffee-script/lib/coffee-script/iced":5}],17:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var k, v, _ref, _ref1;



  _ref = require('./enc');
  for (k in _ref) {
    v = _ref[k];
    exports[k] = v;
  }

  _ref1 = require('./dec');
  for (k in _ref1) {
    v = _ref1[k];
    exports[k] = v;
  }

  exports.prng = require('./prng');

  exports.Buffer = Buffer;

  exports.WordArray = require('./wordarray').WordArray;

  exports.util = require('./util');

  exports.ciphers = {
    AES: require('./aes').AES,
    TwoFish: require('./twofish').TwoFish
  };

  exports.hash = {
    SHA1: require('./sha1').SHA1,
    SHA224: require('./sha224').SHA224,
    SHA256: require('./sha256').SHA256,
    SHA512: require('./sha512').SHA512,
    SHA3: require('./sha3').SHA3
  };

  exports.scrypt = require('./scrypt').scrypt;

}).call(this);

},{"./aes":8,"./dec":12,"./enc":14,"./prng":19,"./scrypt":21,"./sha1":22,"./sha224":23,"./sha256":24,"./sha3":25,"./sha512":26,"./twofish":27,"./util":28,"./wordarray":29,"__browserify_Buffer":3}],18:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var HMAC, PBKDF2, WordArray, iced, pbkdf2, util, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  HMAC = require('./hmac').HMAC;

  WordArray = require('./wordarray').WordArray;

  util = require('./util');

  PBKDF2 = (function() {
    function PBKDF2(_arg) {
      this.klass = _arg.klass, this.c = _arg.c;
      this.c || (this.c = 1024);
      this.klass || (this.klass = HMAC);
    }

    PBKDF2.prototype._PRF = function(input) {
      this.prf.reset();
      return this.prf.finalize(input);
    };

    PBKDF2.prototype._gen_T_i = function(_arg, cb) {
      var U, i, progress_hook, ret, salt, seed, stop, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      salt = _arg.salt, i = _arg.i, progress_hook = _arg.progress_hook;
      progress_hook(0);
      seed = salt.clone().concat(new WordArray([i]));
      U = this._PRF(seed);
      ret = U.clone();
      i = 1;
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _this.c)) {
            return _break();
          } else {
            stop = Math.min(_this.c, i + 128);
            while (i < stop) {
              U = _this._PRF(U);
              ret.xor(U, {});
              i++;
            }
            progress_hook(i);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/pbkdf2.iced",
                funcname: "PBKDF2._gen_T_i"
              });
              util.default_delay(0, 0, __iced_deferrals.defer({
                lineno: 57
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return _next(null);
            });
          }
        };
        _while(__iced_k);
      })(function() {
        progress_hook(i);
        return cb(ret);
      });
    };

    PBKDF2.prototype.run = function(_arg, cb) {
      var bs, dkLen, flat, i, key, n, ph, progress_hook, salt, tmp, tph, words, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;
      this.prf = new this.klass(key);
      bs = this.prf.get_output_size();
      n = Math.ceil(dkLen / bs);
      words = [];
      tph = null;
      ph = function(block) {
        return function(iter) {
          return typeof progress_hook === "function" ? progress_hook({
            what: "pbkdf2",
            total: n * _this.c,
            i: block * _this.c + iter
          }) : void 0;
        };
      };
      ph(0)(0);
      (function(__iced_k) {
        var _i, _results, _while;
        i = 1;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i <= n)) {
            return _break();
          } else {

            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/pbkdf2.iced",
                funcname: "PBKDF2.run"
              });
              _this._gen_T_i({
                salt: salt,
                i: i,
                progress_hook: ph(i - 1)
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return tmp = arguments[0];
                  };
                })(),
                lineno: 80
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return _next(words.push(tmp.words));
            });
          }
        };
        _while(__iced_k);
      })(function() {
        var _ref;
        ph(n)(0);
        flat = (_ref = []).concat.apply(_ref, words);
        key.scrub();
        _this.prf.scrub();
        _this.prf = null;
        return cb(new WordArray(flat, dkLen));
      });
    };

    return PBKDF2;

  })();

  pbkdf2 = function(_arg, cb) {
    var c, dkLen, eng, key, klass, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, salt = _arg.salt, klass = _arg.klass, c = _arg.c, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;
    eng = new PBKDF2({
      klass: klass,
      c: c
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/pbkdf2.iced",
        funcname: "pbkdf2"
      });
      eng.run({
        key: key,
        salt: salt,
        dkLen: dkLen,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return out = arguments[0];
          };
        })(),
        lineno: 106
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb(out);
    });
  };

  exports.pbkdf2 = pbkdf2;

  exports.PBKDF2 = PBKDF2;

}).call(this);

},{"./hmac":15,"./util":28,"./wordarray":29,"iced-coffee-script/lib/coffee-script/iced":5}],19:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ADRBG, PRNG, WordArray, XOR, browser_rng, e, generate, iced, more_entropy, native_rng, rng, util, __iced_k, __iced_k_noop, _prng, _ref;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  more_entropy = require('more-entropy');

  ADRBG = require('./drbg').ADRBG;

  WordArray = require('./wordarray').WordArray;

  XOR = require('./combine').XOR;

  util = require('./util');

  browser_rng = function(n) {
    var v;
    v = new Uint8Array(n);
    window.crypto.getRandomValues(v);
    return new Buffer(v);
  };

  if ((typeof window !== "undefined" && window !== null ? (_ref = window.crypto) != null ? _ref.getRandomValues : void 0 : void 0) != null) {
    native_rng = browser_rng;
  } else {
    try {
      rng = require('cry' + 'pto').rng;
      if (rng != null) {
        native_rng = rng;
      }
    } catch (_error) {
      e = _error;
    }
  }

  if (native_rng == null) {
    throw new Error('No rng found; tried requiring "crypto" and window.crypto');
  }

  PRNG = (function() {
    function PRNG() {
      var _this = this;
      this.meg = new more_entropy.Generator();
      this.adrbg = new ADRBG((function(n, cb) {
        return _this.gen_seed(n, cb);
      }), XOR.sign);
    }

    PRNG.prototype.now_to_buffer = function() {
      var buf, d, ms, s;
      d = Date.now();
      ms = d % 1000;
      s = Math.floor(d / 1000);
      buf = new Buffer(8);
      buf.writeUInt32BE(s, 0);
      buf.writeUInt32BE(ms, 4);
      return buf;
    };

    PRNG.prototype.gen_seed = function(nbits, cb) {
      var b, bufs, cat, nbytes, wa, words, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      nbytes = nbits / 8;
      bufs = [];
      bufs.push(this.now_to_buffer());
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/prng.iced",
          funcname: "PRNG.gen_seed"
        });
        _this.meg.generate(nbits, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return words = arguments[0];
            };
          })(),
          lineno: 68
        }));
        __iced_deferrals._fulfill();
      })(function() {
        var _i, _len;
        bufs.push(_this.now_to_buffer());
        bufs.push(new Buffer(words));
        bufs.push(native_rng(nbytes));
        bufs.push(_this.now_to_buffer());
        cat = Buffer.concat(bufs);
        wa = WordArray.from_buffer(cat);
        util.scrub_buffer(cat);
        for (_i = 0, _len = bufs.length; _i < _len; _i++) {
          b = bufs[_i];
          util.scrub_buffer(b);
        }
        return cb(wa);
      });
    };

    PRNG.prototype.generate = function(n, cb) {
      return this.adrbg.generate(n, cb);
    };

    return PRNG;

  })();

  _prng = null;

  generate = function(n, cb) {
    if (_prng == null) {
      _prng = new PRNG();
    }
    return _prng.generate(n, cb);
  };

  exports.PRNG = PRNG;

  exports.generate = generate;

  exports.native_rng = native_rng;

}).call(this);

},{"./combine":10,"./drbg":13,"./util":28,"./wordarray":29,"__browserify_Buffer":3,"iced-coffee-script/lib/coffee-script/iced":5,"more-entropy":32}],20:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var Cipher, Counter, Salsa20, Salsa20Core, Salsa20InnerCore, Salsa20WordStream, StreamCipher, WordArray, asum, bulk_encrypt, encrypt, endian_reverse, fixup_uint32, iced, util, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('./wordarray'), endian_reverse = _ref.endian_reverse, WordArray = _ref.WordArray;

  Counter = require('./ctr').Counter;

  fixup_uint32 = require('./util').fixup_uint32;

  StreamCipher = require('./algbase').StreamCipher;

  util = require('./util');

  asum = function(out, v) {
    var e, i, _i, _len;
    for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
      e = v[i];
      out[i] += e;
    }
    return false;
  };

  Salsa20InnerCore = (function() {
    function Salsa20InnerCore(rounds) {
      this.rounds = rounds;
    }

    Salsa20InnerCore.prototype._core = function(v) {
      var i, u, x0, x1, x10, x11, x12, x13, x14, x15, x2, x3, x4, x5, x6, x7, x8, x9, _i, _ref1;
      x0 = v[0], x1 = v[1], x2 = v[2], x3 = v[3], x4 = v[4], x5 = v[5], x6 = v[6], x7 = v[7], x8 = v[8], x9 = v[9], x10 = v[10], x11 = v[11], x12 = v[12], x13 = v[13], x14 = v[14], x15 = v[15];
      for (i = _i = 0, _ref1 = this.rounds; _i < _ref1; i = _i += 2) {
        u = (x0 + x12) | 0;
        x4 ^= (u << 7) | (u >>> 25);
        u = (x4 + x0) | 0;
        x8 ^= (u << 9) | (u >>> 23);
        u = (x8 + x4) | 0;
        x12 ^= (u << 13) | (u >>> 19);
        u = (x12 + x8) | 0;
        x0 ^= (u << 18) | (u >>> 14);
        u = (x5 + x1) | 0;
        x9 ^= (u << 7) | (u >>> 25);
        u = (x9 + x5) | 0;
        x13 ^= (u << 9) | (u >>> 23);
        u = (x13 + x9) | 0;
        x1 ^= (u << 13) | (u >>> 19);
        u = (x1 + x13) | 0;
        x5 ^= (u << 18) | (u >>> 14);
        u = (x10 + x6) | 0;
        x14 ^= (u << 7) | (u >>> 25);
        u = (x14 + x10) | 0;
        x2 ^= (u << 9) | (u >>> 23);
        u = (x2 + x14) | 0;
        x6 ^= (u << 13) | (u >>> 19);
        u = (x6 + x2) | 0;
        x10 ^= (u << 18) | (u >>> 14);
        u = (x15 + x11) | 0;
        x3 ^= (u << 7) | (u >>> 25);
        u = (x3 + x15) | 0;
        x7 ^= (u << 9) | (u >>> 23);
        u = (x7 + x3) | 0;
        x11 ^= (u << 13) | (u >>> 19);
        u = (x11 + x7) | 0;
        x15 ^= (u << 18) | (u >>> 14);
        u = (x0 + x3) | 0;
        x1 ^= (u << 7) | (u >>> 25);
        u = (x1 + x0) | 0;
        x2 ^= (u << 9) | (u >>> 23);
        u = (x2 + x1) | 0;
        x3 ^= (u << 13) | (u >>> 19);
        u = (x3 + x2) | 0;
        x0 ^= (u << 18) | (u >>> 14);
        u = (x5 + x4) | 0;
        x6 ^= (u << 7) | (u >>> 25);
        u = (x6 + x5) | 0;
        x7 ^= (u << 9) | (u >>> 23);
        u = (x7 + x6) | 0;
        x4 ^= (u << 13) | (u >>> 19);
        u = (x4 + x7) | 0;
        x5 ^= (u << 18) | (u >>> 14);
        u = (x10 + x9) | 0;
        x11 ^= (u << 7) | (u >>> 25);
        u = (x11 + x10) | 0;
        x8 ^= (u << 9) | (u >>> 23);
        u = (x8 + x11) | 0;
        x9 ^= (u << 13) | (u >>> 19);
        u = (x9 + x8) | 0;
        x10 ^= (u << 18) | (u >>> 14);
        u = (x15 + x14) | 0;
        x12 ^= (u << 7) | (u >>> 25);
        u = (x12 + x15) | 0;
        x13 ^= (u << 9) | (u >>> 23);
        u = (x13 + x12) | 0;
        x14 ^= (u << 13) | (u >>> 19);
        u = (x14 + x13) | 0;
        x15 ^= (u << 18) | (u >>> 14);
      }
      return [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15];
    };

    return Salsa20InnerCore;

  })();

  Salsa20Core = (function(_super) {
    __extends(Salsa20Core, _super);

    Salsa20Core.prototype.sigma = WordArray.from_buffer_le(new Buffer("expand 32-byte k"));

    Salsa20Core.prototype.tau = WordArray.from_buffer_le(new Buffer("expand 16-byte k"));

    Salsa20Core.blockSize = 64;

    Salsa20Core.prototype.blockSize = Salsa20Core.blockSize;

    Salsa20Core.keySize = 32;

    Salsa20Core.prototype.keySize = Salsa20Core.keySize;

    Salsa20Core.ivSize = 192 / 8;

    Salsa20Core.prototype.ivSize = Salsa20Core.ivSize;

    function Salsa20Core(key, nonce) {
      var _ref1;
      Salsa20Core.__super__.constructor.call(this, 20);
      this.key = key.clone().endian_reverse();
      this.nonce = nonce.clone().endian_reverse();
      if (!(((this.key.sigBytes === 16) && (this.nonce.sigBytes === 8)) || ((this.key.sigBytes === 32) && ((_ref1 = this.nonce.sigBytes) === 8 || _ref1 === 24)))) {
        throw new Error("Bad key/nonce lengths");
      }
      if (this.nonce.sigBytes === 24) {
        this.xsalsa_setup();
      }
      this.input = this.key_iv_setup(this.nonce, this.key);
      this._reset();
    }

    Salsa20Core.prototype.scrub = function() {
      this.key.scrub();
      this.nonce.scrub();
      return util.scrub_vec(this.input);
    };

    Salsa20Core.prototype.xsalsa_setup = function() {
      var n0, n1;
      n0 = new WordArray(this.nonce.words.slice(0, 4));
      this.nonce = n1 = new WordArray(this.nonce.words.slice(4));
      return this.key = this.hsalsa20(n0, this.key);
    };

    Salsa20Core.prototype.hsalsa20 = function(nonce, key) {
      var i, indexes, input, v;
      input = this.key_iv_setup(nonce, key);
      input[8] = nonce.words[2];
      input[9] = nonce.words[3];
      v = this._core(input);
      indexes = [0, 5, 10, 15, 6, 7, 8, 9];
      v = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = indexes.length; _i < _len; _i++) {
          i = indexes[_i];
          _results.push(fixup_uint32(v[i]));
        }
        return _results;
      })();
      util.scrub_vec(input);
      return new WordArray(v);
    };

    Salsa20Core.prototype.key_iv_setup = function(nonce, key) {
      var A, C, i, out, _i, _j, _k, _ref1;
      out = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        out[i + 1] = key.words[i];
      }
      _ref1 = key.sigBytes === 32 ? [this.sigma, key.words.slice(4)] : [this.tau, key.words], C = _ref1[0], A = _ref1[1];
      for (i = _j = 0; _j < 4; i = ++_j) {
        out[i + 11] = A[i];
      }
      for (i = _k = 0; _k < 4; i = ++_k) {
        out[i * 5] = C.words[i];
      }
      out[6] = nonce.words[0];
      out[7] = nonce.words[1];
      return out;
    };

    Salsa20Core.prototype.counter_setup = function() {
      this.input[8] = this.counter.get().words[0];
      return this.input[9] = this.counter.get().words[1];
    };

    Salsa20Core.prototype._reset = function() {
      return this.counter = new Counter({
        len: 2
      });
    };

    Salsa20Core.prototype._generateBlock = function() {
      var v;
      this.counter_setup();
      v = this._core(this.input);
      asum(v, this.input);
      this.counter.inc_le();
      return v;
    };

    return Salsa20Core;

  })(Salsa20InnerCore);

  exports.Salsa20WordStream = Salsa20WordStream = (function(_super) {
    __extends(Salsa20WordStream, _super);

    function Salsa20WordStream() {
      _ref1 = Salsa20WordStream.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Salsa20WordStream.prototype._reset = function() {
      return Salsa20WordStream.__super__._reset.call(this);
    };

    Salsa20WordStream.prototype.getWordArray = function(nbytes) {
      var blocks, i, nblocks, w, words, _i, _len, _ref2;
      if ((nbytes == null) || nbytes === this.blockSize) {
        words = this._generateBlock();
      } else {
        nblocks = Math.ceil(nbytes / this.blockSize);
        blocks = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= nblocks ? _i < nblocks : _i > nblocks; i = 0 <= nblocks ? ++_i : --_i) {
            _results.push(this._generateBlock());
          }
          return _results;
        }).call(this);
        words = (_ref2 = []).concat.apply(_ref2, blocks);
      }
      for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {
        w = words[i];
        words[i] = endian_reverse(w);
      }
      return new WordArray(words, nbytes);
    };

    return Salsa20WordStream;

  })(Salsa20Core);

  exports.Salsa20 = Salsa20 = (function(_super) {
    __extends(Salsa20, _super);

    function Salsa20() {
      _ref2 = Salsa20.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Salsa20.prototype._reset = function() {
      Salsa20.__super__._reset.call(this);
      return this._i = this.blockSize;
    };

    Salsa20.prototype.getBytes = function(needed) {
      var bsz, n, v;
      if (needed == null) {
        needed = this.blockSize;
      }
      v = [];
      bsz = this.blockSize;
      if ((this._i === bsz) && (needed === bsz)) {
        return this._generateBlockBuffer();
      } else {
        while (needed > 0) {
          if (this._i === bsz) {
            this._generateBlockBuffer();
            this._i = 0;
          }
          n = Math.min(needed, bsz - this._i);
          v.push((n === bsz ? this._buf : this._buf.slice(this._i, this._i + n)));
          this._i += n;
          needed -= n;
        }
        return Buffer.concat(v);
      }
    };

    Salsa20.prototype._generateBlockBuffer = function() {
      var e, i, v, _i, _len;
      this._buf = new Buffer(this.blockSize);
      v = this._generateBlock();
      for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
        e = v[i];
        this._buf.writeUInt32LE(fixup_uint32(e), i * 4);
      }
      return this._buf;
    };

    return Salsa20;

  })(Salsa20Core);

  exports.Cipher = Cipher = (function(_super) {
    __extends(Cipher, _super);

    function Cipher(_arg) {
      var iv, key;
      key = _arg.key, iv = _arg.iv;
      Cipher.__super__.constructor.call(this);
      this.salsa = new Salsa20WordStream(key, iv);
      this.bsiw = this.salsa.blockSize / 4;
    }

    Cipher.prototype.scrub = function() {
      return this.salsa.scrub();
    };

    Cipher.prototype.get_pad = function() {
      var pad;
      pad = this.salsa.getWordArray();
      return pad;
    };

    return Cipher;

  })(StreamCipher);

  exports.encrypt = encrypt = function(_arg) {
    var cipher, input, iv, key, ret;
    key = _arg.key, iv = _arg.iv, input = _arg.input;
    cipher = new Cipher({
      key: key,
      iv: iv
    });
    ret = cipher.encrypt(input);
    cipher.scrub();
    return ret;
  };

  exports.bulk_encrypt = bulk_encrypt = function(_arg, cb) {
    var cipher, input, iv, key, progress_hook, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, iv = _arg.iv, input = _arg.input, progress_hook = _arg.progress_hook;
    cipher = new Cipher({
      key: key,
      iv: iv
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/salsa20.iced",
        funcname: "bulk_encrypt"
      });
      cipher.bulk_encrypt({
        input: input,
        progress_hook: progress_hook,
        what: "salsa20"
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return ret = arguments[0];
          };
        })(),
        lineno: 256
      }));
      __iced_deferrals._fulfill();
    })(function() {
      cipher.scrub();
      return cb(ret);
    });
  };

  exports.Salsa20InnerCore = Salsa20InnerCore;

  exports.endian_reverse = endian_reverse;

  exports.asum = asum;

}).call(this);

},{"./algbase":9,"./ctr":11,"./util":28,"./wordarray":29,"__browserify_Buffer":3,"iced-coffee-script/lib/coffee-script/iced":5}],21:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var HMAC_SHA256, Salsa20InnerCore, Scrypt, WordArray, blkcpy, blkxor, default_delay, endian_reverse, fixup_uint32, iced, pbkdf2, scrub_vec, scrypt, ui8a_to_buffer, v_endian_reverse, __iced_k, __iced_k_noop, _ref, _ref1, _ref2;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  HMAC_SHA256 = require('./hmac').HMAC_SHA256;

  pbkdf2 = require('./pbkdf2').pbkdf2;

  _ref = require('./salsa20'), endian_reverse = _ref.endian_reverse, Salsa20InnerCore = _ref.Salsa20InnerCore;

  _ref1 = require('./wordarray'), ui8a_to_buffer = _ref1.ui8a_to_buffer, WordArray = _ref1.WordArray;

  _ref2 = require('./util'), fixup_uint32 = _ref2.fixup_uint32, default_delay = _ref2.default_delay, scrub_vec = _ref2.scrub_vec;

  blkcpy = function(D, S, d_offset, s_offset, len) {
    var end, i, j;
    j = d_offset << 4;
    i = s_offset << 4;
    end = i + (len << 4);
    while (i < end) {
      D[j++] = S[i++];
      D[j++] = S[i++];
      D[j++] = S[i++];
      D[j++] = S[i++];
    }
    return true;
  };

  blkxor = function(D, S, s_offset, len) {
    var i, _i;
    s_offset <<= 4;
    len <<= 4;
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      D[i] ^= S[i + s_offset];
    }
    return true;
  };

  v_endian_reverse = function(v) {
    var e, i, _i, _len;
    for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
      e = v[i];
      v[i] = endian_reverse(e);
    }
    return true;
  };

  Scrypt = (function() {
    function Scrypt(_arg) {
      var N, c, c0, c1;
      N = _arg.N, this.r = _arg.r, this.p = _arg.p, c = _arg.c, c0 = _arg.c0, c1 = _arg.c1, this.klass = _arg.klass;
      this.N || (this.N = 1 << (N || 10));
      this.r || (this.r = 16);
      this.p || (this.p = 2);
      this.c0 = c0 || c || 1;
      this.c1 = c1 || c || 1;
      this.klass || (this.klass = HMAC_SHA256);
      this.X16_tmp = new Int32Array(0x10);
      this.s20ic = new Salsa20InnerCore(8);
    }

    Scrypt.prototype.salsa20_8 = function(B) {
      var X, i, x, _i, _len;
      X = this.s20ic._core(B);
      for (i = _i = 0, _len = X.length; _i < _len; i = ++_i) {
        x = X[i];
        B[i] += x;
      }
      return true;
    };

    Scrypt.prototype.pbkdf2 = function(_arg, cb) {
      var c, dkLen, key, progress_hook, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook, c = _arg.c;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/scrypt.iced",
          funcname: "Scrypt.pbkdf2"
        });
        pbkdf2({
          key: key,
          salt: salt,
          c: c,
          dkLen: dkLen,
          klass: _this.klass,
          progress_hook: progress_hook
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return wa = arguments[0];
            };
          })(),
          lineno: 68
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(wa);
      });
    };

    Scrypt.prototype.blockmix_salsa8 = function(B, Y) {
      var X, i, _i, _j, _k, _ref3, _ref4, _ref5;
      X = this.X16_tmp;
      blkcpy(X, B, 0, 2 * this.r - 1, 1);
      for (i = _i = 0, _ref3 = 2 * this.r; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
        blkxor(X, B, i, 1);
        this.salsa20_8(X);
        blkcpy(Y, X, i, 0, 1);
      }
      for (i = _j = 0, _ref4 = this.r; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; i = 0 <= _ref4 ? ++_j : --_j) {
        blkcpy(B, Y, i, i * 2, 1);
      }
      for (i = _k = 0, _ref5 = this.r; 0 <= _ref5 ? _k < _ref5 : _k > _ref5; i = 0 <= _ref5 ? ++_k : --_k) {
        blkcpy(B, Y, i + this.r, i * 2 + 1, 1);
      }
      return true;
    };

    Scrypt.prototype.smix = function(_arg, cb) {
      var B, V, X, XY, Y, i, j, lim, progress_hook, stop, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      B = _arg.B, V = _arg.V, XY = _arg.XY, progress_hook = _arg.progress_hook;
      X = XY;
      lim = 2 * this.r;
      Y = XY.subarray(0x10 * lim);
      blkcpy(X, B, 0, 0, lim);
      i = 0;
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _this.N)) {
            return _break();
          } else {
            stop = Math.min(_this.N, i + 2048);
            while (i < stop) {
              blkcpy(V, X, lim * i, 0, lim);
              _this.blockmix_salsa8(X, Y);
              i++;
            }
            if (typeof progress_hook === "function") {
              progress_hook(i);
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/scrypt.iced",
                funcname: "Scrypt.smix"
              });
              default_delay(0, 0, __iced_deferrals.defer({
                lineno: 121
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        i = 0;
        (function(__iced_k) {
          var _results, _while;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(i < _this.N)) {
              return _break();
            } else {
              stop = Math.min(_this.N, i + 256);
              while (i < stop) {
                j = fixup_uint32(X[0x10 * (lim - 1)]) & (_this.N - 1);
                blkxor(X, V, j * lim, lim);
                _this.blockmix_salsa8(X, Y);
                i++;
              }
              if (typeof progress_hook === "function") {
                progress_hook(i + _this.N);
              }
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/scrypt.iced",
                  funcname: "Scrypt.smix"
                });
                default_delay(0, 0, __iced_deferrals.defer({
                  lineno: 138
                }));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        })(function() {
          blkcpy(B, X, 0, 0, lim);
          return cb();
        });
      });
    };

    Scrypt.prototype.run = function(_arg, cb) {
      var B, MAX, V, XY, dkLen, err, j, key, lph, out, progress_hook, ret, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;
      MAX = 0xffffffff;
      err = ret = null;
      err = dkLen > MAX ? err = new Error("asked for too much data") : this.r * this.p >= (1 << 30) ? new Error("r & p are too big") : (this.r > MAX / 128 / this.p) || (this.r > MAX / 256) || (this.N > MAX / 128 / this.r) ? new Error("N is too big") : null;
      XY = new Int32Array(64 * this.r);
      V = new Int32Array(32 * this.r * this.N);
      lph = function(o) {
        o.what += " (pass 1)";
        return typeof progress_hook === "function" ? progress_hook(o) : void 0;
      };
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/scrypt.iced",
          funcname: "Scrypt.run"
        });
        _this.pbkdf2({
          key: key.clone(),
          salt: salt,
          dkLen: 128 * _this.r * _this.p,
          c: _this.c0,
          progress_hook: lph
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return B = arguments[0];
            };
          })(),
          lineno: 169
        }));
        __iced_deferrals._fulfill();
      })(function() {
        B = new Int32Array(B.words);
        v_endian_reverse(B);
        lph = function(j) {
          return function(i) {
            return typeof progress_hook === "function" ? progress_hook({
              i: i + j * _this.N * 2,
              what: "scrypt",
              total: _this.p * _this.N * 2
            }) : void 0;
          };
        };
        (function(__iced_k) {
          var _i, _results, _while;
          j = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++j;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(j < _this.p)) {
              return _break();
            } else {

              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/scrypt.iced",
                  funcname: "Scrypt.run"
                });
                _this.smix({
                  B: B.subarray(32 * _this.r * j),
                  V: V,
                  XY: XY,
                  progress_hook: lph(j)
                }, __iced_deferrals.defer({
                  lineno: 176
                }));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        })(function() {
          v_endian_reverse(B);
          lph = function(o) {
            o.what += " (pass 2)";
            return typeof progress_hook === "function" ? progress_hook(o) : void 0;
          };
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/scrypt.iced",
              funcname: "Scrypt.run"
            });
            _this.pbkdf2({
              key: key,
              salt: WordArray.from_i32a(B),
              dkLen: dkLen,
              c: _this.c1,
              progress_hook: lph
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return out = arguments[0];
                };
              })(),
              lineno: 184
            }));
            __iced_deferrals._fulfill();
          })(function() {
            scrub_vec(B);
            scrub_vec(XY);
            scrub_vec(V);
            key.scrub();
            return cb(out);
          });
        });
      });
    };

    return Scrypt;

  })();

  scrypt = function(_arg, cb) {
    var N, c, c0, c1, dkLen, eng, key, klass, p, progress_hook, r, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, salt = _arg.salt, r = _arg.r, N = _arg.N, p = _arg.p, c0 = _arg.c0, c1 = _arg.c1, c = _arg.c, klass = _arg.klass, progress_hook = _arg.progress_hook, dkLen = _arg.dkLen;
    eng = new Scrypt({
      r: r,
      N: N,
      p: p,
      c: c,
      c0: c0,
      c1: c1,
      klass: klass
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/scrypt.iced",
        funcname: "scrypt"
      });
      eng.run({
        key: key,
        salt: salt,
        progress_hook: progress_hook,
        dkLen: dkLen
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return wa = arguments[0];
          };
        })(),
        lineno: 214
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb(wa);
    });
  };

  exports.Scrypt = Scrypt;

  exports.scrypt = scrypt;

  exports.v_endian_reverse = v_endian_reverse;

}).call(this);

},{"./hmac":15,"./pbkdf2":18,"./salsa20":20,"./util":28,"./wordarray":29,"iced-coffee-script/lib/coffee-script/iced":5}],22:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Hasher, SHA1, W, WordArray, transform, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  Hasher = require('./algbase').Hasher;

  W = [];

  SHA1 = (function(_super) {
    __extends(SHA1, _super);

    function SHA1() {
      _ref = SHA1.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    SHA1.blockSize = 512 / 32;

    SHA1.prototype.blockSize = SHA1.blockSize;

    SHA1.output_size = 20;

    SHA1.prototype.output_size = SHA1.output_size;

    SHA1.prototype._doReset = function() {
      return this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
    };

    SHA1.prototype._doProcessBlock = function(M, offset) {
      var H, a, b, c, d, e, i, n, t, _i;
      H = this._hash.words;
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      for (i = _i = 0; _i < 80; i = ++_i) {
        if (i < 16) {
          W[i] = M[offset + i] | 0;
        } else {
          n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
          W[i] = (n << 1) | (n >>> 31);
        }
        t = ((a << 5) | (a >>> 27)) + e + W[i];
        if (i < 20) {
          t += ((b & c) | (~b & d)) + 0x5a827999;
        } else if (i < 40) {
          t += (b ^ c ^ d) + 0x6ed9eba1;
        } else if (i < 60) {
          t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
        } else {
          t += (b ^ c ^ d) - 0x359d3e2a;
        }
        e = d;
        d = c;
        c = (b << 30) | (b >>> 2);
        b = a;
        a = t;
      }
      H[0] = (H[0] + a) | 0;
      H[1] = (H[1] + b) | 0;
      H[2] = (H[2] + c) | 0;
      H[3] = (H[3] + d) | 0;
      return H[4] = (H[4] + e) | 0;
    };

    SHA1.prototype._doFinalize = function() {
      var data, dataWords, nBitsLeft, nBitsTotal;
      data = this._data;
      dataWords = data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = data.sigBytes * 8;
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
      data.sigBytes = dataWords.length * 4;
      this._process();
      return this._hash;
    };

    SHA1.prototype.copy_to = function(obj) {
      SHA1.__super__.copy_to.call(this, obj);
      return obj._hash = this._hash.clone();
    };

    SHA1.prototype.clone = function() {
      var out;
      out = new SHA1();
      this.copy_to(out);
      return out;
    };

    return SHA1;

  })(Hasher);

  transform = transform = function(x) {
    var out;
    out = (new SHA1).finalize(x);
    x.scrub();
    return out;
  };

  exports.SHA1 = SHA1;

  exports.transform = transform;

}).call(this);

},{"./algbase":9,"./wordarray":29}],23:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var SHA224, SHA256, WordArray, transform, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  SHA256 = require('./sha256').SHA256;

  SHA224 = (function(_super) {
    __extends(SHA224, _super);

    function SHA224() {
      _ref = SHA224.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    SHA224.prototype._doReset = function() {
      return this._hash = new WordArray([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);
    };

    SHA224.prototype._doFinalize = function() {
      var hash;
      hash = SHA224.__super__._doFinalize.call(this);
      hash.sigBytes -= 4;
      return hash;
    };

    SHA224.prototype.clone = function() {
      var out;
      out = new SHA224();
      this.copy_to(out);
      return out;
    };

    return SHA224;

  })(SHA256);

  transform = function(x) {
    var out;
    out = (new SHA224).finalize(x);
    x.scrub();
    return out;
  };

  exports.SHA224 = SHA224;

  exports.transform = transform;

}).call(this);

},{"./sha256":24,"./wordarray":29}],24:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Global, Hasher, SHA256, WordArray, glbl, transform, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  Hasher = require('./algbase').Hasher;

  Global = (function() {
    function Global() {
      this.H = [];
      this.K = [];
      this.W = [];
      this.init();
    }

    Global.prototype.isPrime = function(n) {
      var f, sqn, _i;
      if (n === 2 || n === 3 || n === 5 || n === 7) {
        return true;
      }
      if (n === 1 || n === 4 || n === 6 || n === 8 || n === 9) {
        return false;
      }
      sqn = Math.ceil(Math.sqrt(n));
      for (f = _i = 2; 2 <= sqn ? _i <= sqn : _i >= sqn; f = 2 <= sqn ? ++_i : --_i) {
        if ((n % f) === 0) {
          return false;
        }
      }
      return true;
    };

    Global.prototype.getFractionalBits = function(n) {
      return ((n - (n | 0)) * 0x100000000) | 0;
    };

    Global.prototype.init = function() {
      var n, nPrime, _results;
      n = 2;
      nPrime = 0;
      _results = [];
      while (nPrime < 64) {
        if (this.isPrime(n)) {
          if (nPrime < 8) {
            this.H[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 2));
          }
          this.K[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 3));
          nPrime++;
        }
        _results.push(n++);
      }
      return _results;
    };

    return Global;

  })();

  glbl = new Global();

  SHA256 = (function(_super) {
    __extends(SHA256, _super);

    function SHA256() {
      _ref = SHA256.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    SHA256.blockSize = 512 / 32;

    SHA256.prototype.blockSize = SHA256.blockSize;

    SHA256.output_size = 256 / 8;

    SHA256.prototype.output_size = SHA256.output_size;

    SHA256.prototype._doReset = function() {
      return this._hash = new WordArray(glbl.H.slice(0));
    };

    SHA256.prototype.get_output_size = function() {
      return this.output_size;
    };

    SHA256.prototype._doProcessBlock = function(M, offset) {
      var H, K, W, a, b, c, ch, d, e, f, g, gamma0, gamma0x, gamma1, gamma1x, h, i, maj, sigma0, sigma1, t1, t2, _i;
      H = this._hash.words;
      W = glbl.W;
      K = glbl.K;
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      f = H[5];
      g = H[6];
      h = H[7];
      for (i = _i = 0; _i < 64; i = ++_i) {
        if (i < 16) {
          W[i] = M[offset + i] | 0;
        } else {
          gamma0x = W[i - 15];
          gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^ ((gamma0x << 14) | (gamma0x >>> 18)) ^ (gamma0x >>> 3);
          gamma1x = W[i - 2];
          gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^ ((gamma1x << 13) | (gamma1x >>> 19)) ^ (gamma1x >>> 10);
          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
        }
        ch = (e & f) ^ (~e & g);
        maj = (a & b) ^ (a & c) ^ (b & c);
        sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
        sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
        t1 = h + sigma1 + ch + K[i] + W[i];
        t2 = sigma0 + maj;
        h = g;
        g = f;
        f = e;
        e = (d + t1) | 0;
        d = c;
        c = b;
        b = a;
        a = (t1 + t2) | 0;
      }
      H[0] = (H[0] + a) | 0;
      H[1] = (H[1] + b) | 0;
      H[2] = (H[2] + c) | 0;
      H[3] = (H[3] + d) | 0;
      H[4] = (H[4] + e) | 0;
      H[5] = (H[5] + f) | 0;
      H[6] = (H[6] + g) | 0;
      return H[7] = (H[7] + h) | 0;
    };

    SHA256.prototype._doFinalize = function() {
      var data, dataWords, nBitsLeft, nBitsTotal;
      data = this._data;
      dataWords = data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = data.sigBytes * 8;
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
      data.sigBytes = dataWords.length * 4;
      this._process();
      return this._hash;
    };

    SHA256.prototype.scrub = function() {
      return this._hash.scrub();
    };

    SHA256.prototype.copy_to = function(obj) {
      SHA256.__super__.copy_to.call(this, obj);
      return obj._hash = this._hash.clone();
    };

    SHA256.prototype.clone = function() {
      var out;
      out = new SHA256();
      this.copy_to(out);
      return out;
    };

    return SHA256;

  })(Hasher);

  transform = function(x) {
    var out;
    out = (new SHA256).finalize(x);
    x.scrub();
    return out;
  };

  exports.SHA256 = SHA256;

  exports.transform = transform;

}).call(this);

},{"./algbase":9,"./wordarray":29}],25:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var Global, Hasher, SHA3, WordArray, X64Word, X64WordArray, glbl, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  _ref = require('./wordarray'), WordArray = _ref.WordArray, X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;

  Hasher = require('./algbase').Hasher;

  Global = (function() {
    function Global() {
      this.RHO_OFFSETS = [];
      this.PI_INDEXES = [];
      this.ROUND_CONSTANTS = [];
      this.T = [];
      this.compute_rho_offsets();
      this.compute_pi_indexes();
      this.compute_round_constants();
      this.make_reusables();
    }

    Global.prototype.compute_rho_offsets = function() {
      var newX, newY, t, x, y, _i, _results;
      x = 1;
      y = 0;
      _results = [];
      for (t = _i = 0; _i < 24; t = ++_i) {
        this.RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;
        newX = y % 5;
        newY = (2 * x + 3 * y) % 5;
        x = newX;
        _results.push(y = newY);
      }
      return _results;
    };

    Global.prototype.compute_pi_indexes = function() {
      var x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i < 5; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j < 5; y = ++_j) {
            _results1.push(this.PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Global.prototype.compute_round_constants = function() {
      var LFSR, bitPosition, i, j, roundConstantLsw, roundConstantMsw, _i, _j, _results;
      LFSR = 0x01;
      _results = [];
      for (i = _i = 0; _i < 24; i = ++_i) {
        roundConstantMsw = 0;
        roundConstantLsw = 0;
        for (j = _j = 0; _j < 7; j = ++_j) {
          if (LFSR & 0x01) {
            bitPosition = (1 << j) - 1;
            if (bitPosition < 32) {
              roundConstantLsw ^= 1 << bitPosition;
            } else {
              roundConstantMsw ^= 1 << (bitPosition - 32);
            }
          }
          if (LFSR & 0x80) {
            LFSR = (LFSR << 1) ^ 0x71;
          } else {
            LFSR <<= 1;
          }
        }
        _results.push(this.ROUND_CONSTANTS[i] = new X64Word(roundConstantMsw, roundConstantLsw));
      }
      return _results;
    };

    Global.prototype.make_reusables = function() {
      var i;
      return this.T = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 25; i = ++_i) {
          _results.push(new X64Word(0, 0));
        }
        return _results;
      })();
    };

    return Global;

  })();

  glbl = new Global();

  exports.SHA3 = SHA3 = (function(_super) {
    __extends(SHA3, _super);

    function SHA3() {
      _ref1 = SHA3.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SHA3.outputLength = 512;

    SHA3.prototype.outputLength = SHA3.outputLength;

    SHA3.blockSize = (1600 - 2 * SHA3.outputLength) / 32;

    SHA3.prototype.blockSize = SHA3.blockSize;

    SHA3.output_size = SHA3.outputLength / 8;

    SHA3.prototype.output_size = SHA3.output_size;

    SHA3.prototype._doReset = function() {
      var i;
      return this._state = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 25; i = ++_i) {
          _results.push(new X64Word(0, 0));
        }
        return _results;
      })();
    };

    SHA3.prototype._doProcessBlock = function(M, offset) {
      var G, M2i, M2i1, T0, TLane, TPiLane, Tx, Tx1, Tx1Lane, Tx1Lsw, Tx1Msw, Tx2Lane, Tx4, i, lane, laneIndex, laneLsw, laneMsw, nBlockSizeLanes, rhoOffset, round, roundConstant, state, state0, tLsw, tMsw, x, y, _i, _j, _k, _l, _m, _n, _o, _p, _q, _results;
      G = glbl;
      state = this._state;
      nBlockSizeLanes = this.blockSize / 2;
      for (i = _i = 0; 0 <= nBlockSizeLanes ? _i < nBlockSizeLanes : _i > nBlockSizeLanes; i = 0 <= nBlockSizeLanes ? ++_i : --_i) {
        M2i = M[offset + 2 * i];
        M2i1 = M[offset + 2 * i + 1];
        M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff) | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);
        M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff) | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);
        lane = state[i];
        lane.high ^= M2i1;
        lane.low ^= M2i;
      }
      _results = [];
      for (round = _j = 0; _j < 24; round = ++_j) {
        for (x = _k = 0; _k < 5; x = ++_k) {
          tMsw = tLsw = 0;
          for (y = _l = 0; _l < 5; y = ++_l) {
            lane = state[x + 5 * y];
            tMsw ^= lane.high;
            tLsw ^= lane.low;
          }
          Tx = G.T[x];
          Tx.high = tMsw;
          Tx.low = tLsw;
        }
        for (x = _m = 0; _m < 5; x = ++_m) {
          Tx4 = G.T[(x + 4) % 5];
          Tx1 = G.T[(x + 1) % 5];
          Tx1Msw = Tx1.high;
          Tx1Lsw = Tx1.low;
          tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
          tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
          for (y = _n = 0; _n < 5; y = ++_n) {
            lane = state[x + 5 * y];
            lane.high ^= tMsw;
            lane.low ^= tLsw;
          }
        }
        for (laneIndex = _o = 1; _o < 25; laneIndex = ++_o) {
          lane = state[laneIndex];
          laneMsw = lane.high;
          laneLsw = lane.low;
          rhoOffset = G.RHO_OFFSETS[laneIndex];
          if (rhoOffset < 32) {
            tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
            tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
          } else {
            tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
            tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
          }
          TPiLane = G.T[G.PI_INDEXES[laneIndex]];
          TPiLane.high = tMsw;
          TPiLane.low = tLsw;
        }
        T0 = G.T[0];
        state0 = state[0];
        T0.high = state0.high;
        T0.low = state0.low;
        for (x = _p = 0; _p < 5; x = ++_p) {
          for (y = _q = 0; _q < 5; y = ++_q) {
            laneIndex = x + 5 * y;
            lane = state[laneIndex];
            TLane = G.T[laneIndex];
            Tx1Lane = G.T[((x + 1) % 5) + 5 * y];
            Tx2Lane = G.T[((x + 2) % 5) + 5 * y];
            lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
            lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);
          }
        }
        lane = state[0];
        roundConstant = G.ROUND_CONSTANTS[round];
        lane.high ^= roundConstant.high;
        _results.push(lane.low ^= roundConstant.low);
      }
      return _results;
    };

    SHA3.prototype._doFinalize = function() {
      var blockSizeBits, data, dataWords, hashWords, i, lane, laneLsw, laneMsw, nBitsLeft, nBitsTotal, outputLengthBytes, outputLengthLanes, state, _i;
      data = this._data;
      dataWords = data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = data.sigBytes * 8;
      blockSizeBits = this.blockSize * 32;
      dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
      dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
      data.sigBytes = dataWords.length * 4;
      this._process();
      state = this._state;
      outputLengthBytes = this.outputLength / 8;
      outputLengthLanes = outputLengthBytes / 8;
      hashWords = [];
      for (i = _i = 0; 0 <= outputLengthLanes ? _i < outputLengthLanes : _i > outputLengthLanes; i = 0 <= outputLengthLanes ? ++_i : --_i) {
        lane = state[i];
        laneMsw = lane.high;
        laneLsw = lane.low;
        laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff) | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);
        laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff) | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);
        hashWords.push(laneLsw);
        hashWords.push(laneMsw);
      }
      return new WordArray(hashWords, outputLengthBytes);
    };

    SHA3.prototype.copy_to = function(obj) {
      var s;
      SHA3.__super__.copy_to.call(this, obj);
      return obj._state = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this._state;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          s = _ref2[_i];
          _results.push(s.clone());
        }
        return _results;
      }).call(this);
    };

    SHA3.prototype.scrub = function() {};

    SHA3.prototype.clone = function() {
      var out;
      out = new SHA3();
      this.copy_to(out);
      return out;
    };

    return SHA3;

  })(Hasher);

  exports.transform = function(x) {
    var out;
    out = (new SHA3).finalize(x);
    x.scrub();
    return out;
  };

}).call(this);

},{"./algbase":9,"./wordarray":29}],26:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Global, Hasher, SHA512, X64Word, X64WordArray, glbl, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  _ref = require('./wordarray'), X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;

  Hasher = require('./algbase').Hasher;

  Global = (function() {
    Global.prototype.convert = function(raw) {
      var i, _i, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref1 = raw.length; _i < _ref1; i = _i += 2) {
        _results.push(new X64Word(raw[i], raw[i + 1]));
      }
      return _results;
    };

    function Global() {
      var i;
      this.K = this.convert([0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817]);
      this.I = new X64WordArray(this.convert([0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179]));
      this.W = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 80; i = ++_i) {
          _results.push(new X64Word(0, 0));
        }
        return _results;
      })();
    }

    return Global;

  })();

  glbl = new Global();

  exports.SHA512 = SHA512 = (function(_super) {
    __extends(SHA512, _super);

    function SHA512() {
      _ref1 = SHA512.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SHA512.blockSize = 1024 / 32;

    SHA512.prototype.blockSize = SHA512.blockSize;

    SHA512.output_size = 512 / 8;

    SHA512.prototype.output_size = SHA512.output_size;

    SHA512.prototype._doReset = function() {
      return this._hash = glbl.I.clone();
    };

    SHA512.prototype._doProcessBlock = function(M, offset) {
      var H, H0, H0h, H0l, H1, H1h, H1l, H2, H2h, H2l, H3, H3h, H3l, H4, H4h, H4l, H5, H5h, H5l, H6, H6h, H6l, H7, H7h, H7l, Ki, Kih, Kil, W, Wi, Wi16, Wi16h, Wi16l, Wi7, Wi7h, Wi7l, Wih, Wil, ah, al, bh, bl, ch, chh, chl, cl, dh, dl, eh, el, fh, fl, gamma0h, gamma0l, gamma0x, gamma0xh, gamma0xl, gamma1h, gamma1l, gamma1x, gamma1xh, gamma1xl, gh, gl, hh, hl, i, majh, majl, sigma0h, sigma0l, sigma1h, sigma1l, t1h, t1l, t2h, t2l, _i;
      H = this._hash.words;
      W = glbl.W;
      H0 = H[0];
      H1 = H[1];
      H2 = H[2];
      H3 = H[3];
      H4 = H[4];
      H5 = H[5];
      H6 = H[6];
      H7 = H[7];
      H0h = H0.high;
      H0l = H0.low;
      H1h = H1.high;
      H1l = H1.low;
      H2h = H2.high;
      H2l = H2.low;
      H3h = H3.high;
      H3l = H3.low;
      H4h = H4.high;
      H4l = H4.low;
      H5h = H5.high;
      H5l = H5.low;
      H6h = H6.high;
      H6l = H6.low;
      H7h = H7.high;
      H7l = H7.low;
      ah = H0h;
      al = H0l;
      bh = H1h;
      bl = H1l;
      ch = H2h;
      cl = H2l;
      dh = H3h;
      dl = H3l;
      eh = H4h;
      el = H4l;
      fh = H5h;
      fl = H5l;
      gh = H6h;
      gl = H6l;
      hh = H7h;
      hl = H7l;
      for (i = _i = 0; _i < 80; i = ++_i) {
        Wi = W[i];
        if (i < 16) {
          Wih = Wi.high = M[offset + i * 2] | 0;
          Wil = Wi.low = M[offset + i * 2 + 1] | 0;
        } else {
          gamma0x = W[i - 15];
          gamma0xh = gamma0x.high;
          gamma0xl = gamma0x.low;
          gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
          gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));
          gamma1x = W[i - 2];
          gamma1xh = gamma1x.high;
          gamma1xl = gamma1x.low;
          gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
          gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));
          Wi7 = W[i - 7];
          Wi7h = Wi7.high;
          Wi7l = Wi7.low;
          Wi16 = W[i - 16];
          Wi16h = Wi16.high;
          Wi16l = Wi16.low;
          Wil = gamma0l + Wi7l;
          Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
          Wil = Wil + gamma1l;
          Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
          Wil = Wil + Wi16l;
          Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);
          Wi.high = Wih;
          Wi.low = Wil;
        }
        chh = (eh & fh) ^ (~eh & gh);
        chl = (el & fl) ^ (~el & gl);
        majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
        majl = (al & bl) ^ (al & cl) ^ (bl & cl);
        sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
        sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
        sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
        sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));
        Ki = glbl.K[i];
        Kih = Ki.high;
        Kil = Ki.low;
        t1l = hl + sigma1l;
        t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
        t1l = t1l + chl;
        t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
        t1l = t1l + Kil;
        t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
        t1l = t1l + Wil;
        t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);
        t2l = sigma0l + majl;
        t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = (dl + t1l) | 0;
        eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = (t1l + t2l) | 0;
        ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
      }
      H0l = H0.low = H0l + al;
      H0.high = H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0);
      H1l = H1.low = H1l + bl;
      H1.high = H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0);
      H2l = H2.low = H2l + cl;
      H2.high = H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0);
      H3l = H3.low = H3l + dl;
      H3.high = H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0);
      H4l = H4.low = H4l + el;
      H4.high = H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0);
      H5l = H5.low = H5l + fl;
      H5.high = H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0);
      H6l = H6.low = H6l + gl;
      H6.high = H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0);
      H7l = H7.low = H7l + hl;
      return H7.high = H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0);
    };

    SHA512.prototype._doFinalize = function() {
      var dataWords, nBitsLeft, nBitsTotal;
      dataWords = this._data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = this._data.sigBytes * 8;
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
      this._data.sigBytes = dataWords.length * 4;
      this._process();
      return this._hash.toX32();
    };

    SHA512.prototype.copy_to = function(obj) {
      SHA512.__super__.copy_to.call(this, obj);
      return obj._hash = this._hash.clone();
    };

    SHA512.prototype.clone = function() {
      var out;
      out = new SHA512();
      this.copy_to(out);
      return out;
    };

    return SHA512;

  })(Hasher);

  exports.transform = function(x) {
    var out;
    out = (new SHA512).finalize(x);
    x.scrub();
    return out;
  };

}).call(this);

},{"./algbase":9,"./wordarray":29}],27:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var BlockCipher, G, Global, TwoFish, scrub_vec,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  BlockCipher = require('./algbase').BlockCipher;

  scrub_vec = require('./util').scrub_vec;

  Global = (function() {
    function Global() {
      this.P = [[0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0], [0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91]];
      this.P_00 = 1;
      this.P_01 = 0;
      this.P_02 = 0;
      this.P_03 = 1;
      this.P_04 = 1;
      this.P_10 = 0;
      this.P_11 = 0;
      this.P_12 = 1;
      this.P_13 = 1;
      this.P_14 = 0;
      this.P_20 = 1;
      this.P_21 = 1;
      this.P_22 = 0;
      this.P_23 = 0;
      this.P_24 = 0;
      this.P_30 = 0;
      this.P_31 = 1;
      this.P_32 = 1;
      this.P_33 = 0;
      this.P_34 = 1;
      this.GF256_FDBK = 0x169;
      this.GF256_FDBK_2 = this.GF256_FDBK / 2;
      this.GF256_FDBK_4 = this.GF256_FDBK / 4;
      this.RS_GF_FDBK = 0x14D;
      this.SK_STEP = 0x02020202;
      this.SK_BUMP = 0x01010101;
      this.SK_ROTL = 9;
    }

    return Global;

  })();

  G = new Global();

  exports.TwoFish = TwoFish = (function(_super) {
    __extends(TwoFish, _super);

    TwoFish.blockSize = 4 * 4;

    TwoFish.prototype.blockSize = TwoFish.blockSize;

    TwoFish.keySize = 256 / 8;

    TwoFish.prototype.keySize = TwoFish.keySize;

    TwoFish.ivSize = TwoFish.blockSize;

    TwoFish.prototype.ivSize = TwoFish.ivSize;

    function TwoFish(key) {
      this._key = key.clone();
      this.gMDS0 = [];
      this.gMDS1 = [];
      this.gMDS2 = [];
      this.gMDS3 = [];
      this.gSubKeys = [];
      this.gSBox = [];
      this.k64Cnt = 0;
      this._doReset();
    }

    TwoFish.prototype.getByte = function(x, n) {
      return (x >>> (n * 8)) & 0xFF;
    };

    TwoFish.prototype.switchEndianness = function(word) {
      return ((word & 0xff) << 24) | (((word >> 8) & 0xff) << 16) | (((word >> 16) & 0xff) << 8) | ((word >> 24) & 0xff);
    };

    TwoFish.prototype.LFSR1 = function(x) {
      return (x >> 1) ^ ((x & 0x01) !== 0 ? G.GF256_FDBK_2 : 0);
    };

    TwoFish.prototype.LFSR2 = function(x) {
      return (x >> 2) ^ ((x & 0x02) !== 0 ? G.GF256_FDBK_2 : 0) ^ ((x & 0x01) !== 0 ? G.GF256_FDBK_4 : 0);
    };

    TwoFish.prototype.Mx_X = function(x) {
      return x ^ this.LFSR2(x);
    };

    TwoFish.prototype.Mx_Y = function(x) {
      return x ^ this.LFSR1(x) ^ this.LFSR2(x);
    };

    TwoFish.prototype.RS_rem = function(x) {
      var b, g2, g3;
      b = (x >>> 24) & 0xff;
      g2 = ((b << 1) ^ ((b & 0x80) !== 0 ? G.RS_GF_FDBK : 0)) & 0xff;
      g3 = ((b >>> 1) ^ ((b & 0x01) !== 0 ? G.RS_GF_FDBK >>> 1 : 0)) ^ g2;
      return (x << 8) ^ (g3 << 24) ^ (g2 << 16) ^ (g3 << 8) ^ b;
    };

    TwoFish.prototype.RS_MDS_Encode = function(k0, k1) {
      var i, r, _i, _j;
      r = k1;
      for (i = _i = 0; _i < 4; i = ++_i) {
        r = this.RS_rem(r);
      }
      r ^= k0;
      for (i = _j = 0; _j < 4; i = ++_j) {
        r = this.RS_rem(r);
      }
      return r;
    };

    TwoFish.prototype.F32 = function(x, k32) {
      var b0, b1, b2, b3, k0, k1, k2, k3, m, res;
      b0 = this.getByte(x, 0);
      b1 = this.getByte(x, 1);
      b2 = this.getByte(x, 2);
      b3 = this.getByte(x, 3);
      k0 = k32[0];
      k1 = k32[1];
      k2 = k32[2];
      k3 = k32[3];
      m = this.k64Cnt & 3;
      res = m === 1 ? this.gMDS0[(G.P[G.P_01][b0] & 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][b1] & 0xff) ^ this.getByte(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][b2] & 0xff) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][b3] & 0xff) ^ this.getByte(k0, 3)] : (m === 0 ? (b0 = (G.P[G.P_04][b0] & 0xff) ^ this.getByte(k3, 0), b1 = (G.P[G.P_14][b1] & 0xff) ^ this.getByte(k3, 1), b2 = (G.P[G.P_24][b2] & 0xff) ^ this.getByte(k3, 2), b3 = (G.P[G.P_34][b3] & 0xff) ^ this.getByte(k3, 3)) : void 0, m === 0 || m === 3 ? (b0 = (G.P[G.P_03][b0] & 0xff) ^ this.getByte(k2, 0), b1 = (G.P[G.P_13][b1] & 0xff) ^ this.getByte(k2, 1), b2 = (G.P[G.P_23][b2] & 0xff) ^ this.getByte(k2, 2), b3 = (G.P[G.P_33][b3] & 0xff) ^ this.getByte(k2, 3)) : void 0, this.gMDS0[(G.P[G.P_01][(G.P[G.P_02][b0] & 0xff) ^ this.getByte(k1, 0)] & 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] & 0xff) ^ this.getByte(k1, 1)] & 0xff) ^ this.getByte(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] & 0xff) ^ this.getByte(k1, 2)] & 0xff) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] & 0xff) ^ this.getByte(k1, 3)] & 0xff) ^ this.getByte(k0, 3)]);
      return res;
    };

    TwoFish.prototype.Fe32_0 = function(x) {
      return this.gSBox[0x000 + 2 * (x & 0xff)] ^ this.gSBox[0x001 + 2 * ((x >>> 8) & 0xff)] ^ this.gSBox[0x200 + 2 * ((x >>> 16) & 0xff)] ^ this.gSBox[0x201 + 2 * ((x >>> 24) & 0xff)];
    };

    TwoFish.prototype.Fe32_3 = function(x) {
      return this.gSBox[0x000 + 2 * ((x >>> 24) & 0xff)] ^ this.gSBox[0x001 + 2 * (x & 0xff)] ^ this.gSBox[0x200 + 2 * ((x >>> 8) & 0xff)] ^ this.gSBox[0x201 + 2 * ((x >>> 16) & 0xff)];
    };

    TwoFish.prototype._doReset = function() {
      var A, B, b0, b1, b2, b3, i, j, k0, k1, k2, k3, k32e, k32o, m, m1, mX, mY, p, q, sBoxKeys, _i, _j, _k, _l, _ref, _ref1, _results;
      k32e = [];
      k32o = [];
      sBoxKeys = [];
      m1 = [];
      mX = [];
      mY = [];
      this.k64Cnt = this._key.words.length / 2;
      if (this.k64Cnt < 1) {
        throw "Key size less than 64 bits";
      }
      if (this.k64Cnt > 4) {
        throw "Key size larger than 256 bits";
      }
      for (i = _i = 0; _i < 256; i = ++_i) {
        j = G.P[0][i] & 0xff;
        m1[0] = j;
        mX[0] = this.Mx_X(j) & 0xff;
        mY[0] = this.Mx_Y(j) & 0xff;
        j = G.P[1][i] & 0xff;
        m1[1] = j;
        mX[1] = this.Mx_X(j) & 0xff;
        mY[1] = this.Mx_Y(j) & 0xff;
        this.gMDS0[i] = m1[G.P_00] | mX[G.P_00] << 8 | mY[G.P_00] << 16 | mY[G.P_00] << 24;
        this.gMDS1[i] = mY[G.P_10] | mY[G.P_10] << 8 | mX[G.P_10] << 16 | m1[G.P_10] << 24;
        this.gMDS2[i] = mX[G.P_20] | mY[G.P_20] << 8 | m1[G.P_20] << 16 | mY[G.P_20] << 24;
        this.gMDS3[i] = mX[G.P_30] | m1[G.P_30] << 8 | mY[G.P_30] << 16 | mX[G.P_30] << 24;
      }
      for (i = _j = 0, _ref = this.k64Cnt; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        p = i * 2;
        k32e[i] = this.switchEndianness(this._key.words[p]);
        k32o[i] = this.switchEndianness(this._key.words[p + 1]);
        sBoxKeys[this.k64Cnt - 1 - i] = this.RS_MDS_Encode(k32e[i], k32o[i]);
      }
      for (i = _k = 0, _ref1 = 40 / 2; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        q = i * G.SK_STEP;
        A = this.F32(q, k32e);
        B = this.F32(q + G.SK_BUMP, k32o);
        B = B << 8 | B >>> 24;
        A += B;
        this.gSubKeys[i * 2] = A;
        A += B;
        this.gSubKeys[i * 2 + 1] = A << G.SK_ROTL | A >>> (32 - G.SK_ROTL);
      }
      k0 = sBoxKeys[0];
      k1 = sBoxKeys[1];
      k2 = sBoxKeys[2];
      k3 = sBoxKeys[3];
      this.gSBox = [];
      _results = [];
      for (i = _l = 0; _l < 256; i = ++_l) {
        b0 = b1 = b2 = b3 = i;
        m = this.k64Cnt & 3;
        if (m === 1) {
          this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][b0] & 0xff) ^ this.getByte(k0, 0)];
          this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][b1] & 0xff) ^ this.getByte(k0, 1)];
          this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][b2] & 0xff) ^ this.getByte(k0, 2)];
          _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][b3] & 0xff) ^ this.getByte(k0, 3)]);
        } else {
          if (m === 0) {
            b0 = (G.P[G.P_04][b0] & 0xff) ^ this.getByte(k3, 0);
            b1 = (G.P[G.P_14][b1] & 0xff) ^ this.getByte(k3, 1);
            b2 = (G.P[G.P_24][b2] & 0xff) ^ this.getByte(k3, 2);
            b3 = (G.P[G.P_34][b3] & 0xff) ^ this.getByte(k3, 3);
          }
          if (m === 0 || m === 3) {
            b0 = (G.P[G.P_03][b0] & 0xff) ^ this.getByte(k2, 0);
            b1 = (G.P[G.P_13][b1] & 0xff) ^ this.getByte(k2, 1);
            b2 = (G.P[G.P_23][b2] & 0xff) ^ this.getByte(k2, 2);
            b3 = (G.P[G.P_33][b3] & 0xff) ^ this.getByte(k2, 3);
          }
          this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][(G.P[G.P_02][b0] & 0xff) ^ this.getByte(k1, 0)] & 0xff) ^ this.getByte(k0, 0)];
          this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] & 0xff) ^ this.getByte(k1, 1)] & 0xff) ^ this.getByte(k0, 1)];
          this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] & 0xff) ^ this.getByte(k1, 2)] & 0xff) ^ this.getByte(k0, 2)];
          _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] & 0xff) ^ this.getByte(k1, 3)] & 0xff) ^ this.getByte(k0, 3)]);
        }
      }
      return _results;
    };

    TwoFish.prototype.scrub = function() {
      scrub_vec(this.gSubKeys);
      scrub_vec(this.gSBox);
      return this._key.scrub();
    };

    TwoFish.prototype.decryptBlock = function(M, offset) {
      var k, r, t0, t1, x0, x1, x2, x3, _i;
      if (offset == null) {
        offset = 0;
      }
      x2 = this.switchEndianness(M[offset]) ^ this.gSubKeys[4];
      x3 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[5];
      x0 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[6];
      x1 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[7];
      k = 8 + 2 * 16 - 1;
      for (r = _i = 0; _i < 16; r = _i += 2) {
        t0 = this.Fe32_0(x2);
        t1 = this.Fe32_3(x3);
        x1 ^= t0 + 2 * t1 + this.gSubKeys[k--];
        x0 = (x0 << 1 | x0 >>> 31) ^ (t0 + t1 + this.gSubKeys[k--]);
        x1 = x1 >>> 1 | x1 << 31;
        t0 = this.Fe32_0(x0);
        t1 = this.Fe32_3(x1);
        x3 ^= t0 + 2 * t1 + this.gSubKeys[k--];
        x2 = (x2 << 1 | x2 >>> 31) ^ (t0 + t1 + this.gSubKeys[k--]);
        x3 = x3 >>> 1 | x3 << 31;
      }
      M[offset] = this.switchEndianness(x0 ^ this.gSubKeys[0]);
      M[offset + 1] = this.switchEndianness(x1 ^ this.gSubKeys[1]);
      M[offset + 2] = this.switchEndianness(x2 ^ this.gSubKeys[2]);
      return M[offset + 3] = this.switchEndianness(x3 ^ this.gSubKeys[3]);
    };

    TwoFish.prototype.encryptBlock = function(M, offset) {
      var k, r, t0, t1, x0, x1, x2, x3, _i;
      if (offset == null) {
        offset = 0;
      }
      x0 = this.switchEndianness(M[offset]) ^ this.gSubKeys[0];
      x1 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[1];
      x2 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[2];
      x3 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[3];
      k = 8;
      for (r = _i = 0; _i < 16; r = _i += 2) {
        t0 = this.Fe32_0(x0);
        t1 = this.Fe32_3(x1);
        x2 ^= t0 + t1 + this.gSubKeys[k++];
        x2 = x2 >>> 1 | x2 << 31;
        x3 = (x3 << 1 | x3 >>> 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);
        t0 = this.Fe32_0(x2);
        t1 = this.Fe32_3(x3);
        x0 ^= t0 + t1 + this.gSubKeys[k++];
        x0 = x0 >>> 1 | x0 << 31;
        x1 = (x1 << 1 | x1 >>> 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);
      }
      M[offset] = this.switchEndianness(x2 ^ this.gSubKeys[4]);
      M[offset + 1] = this.switchEndianness(x3 ^ this.gSubKeys[5]);
      M[offset + 2] = this.switchEndianness(x0 ^ this.gSubKeys[6]);
      return M[offset + 3] = this.switchEndianness(x1 ^ this.gSubKeys[7]);
    };

    return TwoFish;

  })(BlockCipher);

}).call(this);

},{"./algbase":9,"./util":28}],28:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var default_delay, iced, uint_max, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  uint_max = Math.pow(2, 32);

  exports.fixup_uint32 = function(x) {
    var ret, x_pos;
    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
    return ret;
  };

  exports.scrub_buffer = function(b) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(b.writeUInt8(0, i));
    }
    return _results;
  };

  exports.scrub_vec = function(v) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(v[i] = 0);
    }
    return _results;
  };

  exports.default_delay = default_delay = function(i, n, cb) {
    var ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      if (typeof setImmediate !== "undefined" && setImmediate !== null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/util.iced",
            funcname: "default_delay"
          });
          setImmediate(__iced_deferrals.defer({
            lineno: 29
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/util.iced",
            funcname: "default_delay"
          });
          setTimeout(__iced_deferrals.defer({
            lineno: 31
          }), 1);
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    })(function() {
      return cb();
    });
  };

  exports.bulk = function(n_input_bytes, _arg, _arg1) {
    var call_ph, cb, default_n, delay, finalize, i, left, n, n_words, progress_hook, ret, total_words, update, what, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    update = _arg.update, finalize = _arg.finalize, default_n = _arg.default_n;
    delay = _arg1.delay, n = _arg1.n, cb = _arg1.cb, what = _arg1.what, progress_hook = _arg1.progress_hook;
    i = 0;
    left = 0;
    total_words = Math.ceil(n_input_bytes / 4);
    delay || (delay = default_delay);
    n || (n = default_n);
    call_ph = function(i) {
      return typeof progress_hook === "function" ? progress_hook({
        what: what,
        i: i,
        total: total_words
      }) : void 0;
    };
    call_ph(0);
    (function(__iced_k) {
      var _results, _while;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!((left = total_words - i) > 0)) {
          return _break();
        } else {
          n_words = Math.min(n, left);
          update(i, i + n_words);
          call_ph(i);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/util.iced",
              funcname: "bulk"
            });
            delay(i, total_words, __iced_deferrals.defer({
              lineno: 65
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return _next(i += n_words);
          });
        }
      };
      _while(__iced_k);
    })(function() {
      call_ph(total_words);
      ret = finalize();
      return cb(ret);
    });
  };

}).call(this);

},{"iced-coffee-script/lib/coffee-script/iced":5}],29:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var WordArray, X64Word, X64WordArray, buffer_to_ui8a, endian_reverse, ui8a_to_buffer, util;



  util = require('./util');

  buffer_to_ui8a = function(b) {
    var i, ret, _i, _ref;
    ret = new Uint8Array(b.length);
    for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ret[i] = b.readUInt8(i);
    }
    return ret;
  };

  ui8a_to_buffer = function(v) {
    var i, ret, _i, _ref;
    ret = new Buffer(v.length);
    for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ret.writeUInt8(v[i], i);
    }
    return ret;
  };

  endian_reverse = function(x) {
    return ((x >>> 24) & 0xff) | (((x >>> 16) & 0xff) << 8) | (((x >>> 8) & 0xff) << 16) | ((x & 0xff) << 24);
  };

  exports.WordArray = WordArray = (function() {
    function WordArray(words, sigBytes) {
      this.words = words || [];
      this.sigBytes = sigBytes != null ? sigBytes : this.words.length * 4;
    }

    WordArray.prototype.concat = function(wordArray) {
      var i, thatByte, thatSigBytes, thatWords, _i;
      thatWords = wordArray.words;
      thatSigBytes = wordArray.sigBytes;
      this.clamp();
      if (this.sigBytes % 4) {
        for (i = _i = 0; 0 <= thatSigBytes ? _i < thatSigBytes : _i > thatSigBytes; i = 0 <= thatSigBytes ? ++_i : --_i) {
          thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
          this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);
        }
      } else {
        this.words = this.words.concat(thatWords);
      }
      this.sigBytes += thatSigBytes;
      return this;
    };

    WordArray.prototype.clamp = function() {
      this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);
      this.words.length = Math.ceil(this.sigBytes / 4);
      return this;
    };

    WordArray.prototype.clone = function() {
      return new WordArray(this.words.slice(0), this.sigBytes);
    };

    WordArray.prototype.to_buffer = function() {
      var ch, out, p, w, _i, _len, _ref;
      out = new Buffer(this.sigBytes);
      p = 0;
      _ref = this.words;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        if (!((this.sigBytes - p) >= 4)) {
          continue;
        }
        w = util.fixup_uint32(w);
        out.writeUInt32BE(w, p);
        p += 4;
      }
      while (p < this.sigBytes) {
        ch = (this.words[p >>> 2] >>> (24 - (p % 4) * 8)) & 0xff;
        out.writeUInt8(ch, p);
        p++;
      }
      return out;
    };

    WordArray.prototype.endian_reverse = function() {
      var i, w, _i, _len, _ref;
      _ref = this.words;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        w = _ref[i];
        this.words[i] = endian_reverse(w);
      }
      return this;
    };

    WordArray.prototype.split = function(n) {
      var i, out, sz;
      if (!(((this.sigBytes % 4) === 0) && ((this.words.length % n) === 0))) {
        throw new Error("bad key alignment");
      }
      sz = this.words.length / n;
      out = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.words.length; sz > 0 ? _i < _ref : _i > _ref; i = _i += sz) {
          _results.push(new WordArray(this.words.slice(i, i + sz)));
        }
        return _results;
      }).call(this);
      return out;
    };

    WordArray.prototype.to_utf8 = function() {
      return this.to_buffer().toString('utf8');
    };

    WordArray.prototype.to_hex = function() {
      return this.to_buffer().toString('hex');
    };

    WordArray.prototype.to_ui8a = function() {
      return buffer_to_ui8a(this.to_buffer());
    };

    WordArray.alloc = function(b) {
      if (Buffer.isBuffer(b)) {
        return WordArray.from_buffer(b);
      } else if ((typeof b === 'object') && (b instanceof WordArray)) {
        return b;
      } else if (typeof b === 'string') {
        return WordArray.from_hex(b);
      } else {
        return null;
      }
    };

    WordArray.from_buffer = function(b) {
      var ch, last, p, words;
      words = [];
      p = 0;
      while ((b.length - p) >= 4) {
        words.push(b.readUInt32BE(p));
        p += 4;
      }
      if (p < b.length) {
        last = 0;
        while (p < b.length) {
          ch = b.readUInt8(p);
          last |= ch << (24 - (p % 4) * 8);
          p++;
        }
        last = util.fixup_uint32(last);
        words.push(last);
      }
      return new WordArray(words, b.length);
    };

    WordArray.from_buffer_le = function(b) {
      var ch, last, p, words;
      words = [];
      p = 0;
      while ((b.length - p) >= 4) {
        words.push(b.readUInt32LE(p));
        p += 4;
      }
      if (p < b.length) {
        last = 0;
        while (p < b.length) {
          ch = b.readUInt8(p);
          last |= ch << ((p % 4) * 8);
          p++;
        }
        last = util.fixup_uint32(last);
        words.push(last);
      }
      return new WordArray(words, b.length);
    };

    WordArray.from_utf8 = function(s) {
      return WordArray.from_buffer(new Buffer(s, 'utf8'));
    };

    WordArray.from_utf8_le = function(s) {
      return WordArray.from_buffer_le(new Buffer(s, 'utf8'));
    };

    WordArray.from_hex = function(s) {
      return WordArray.from_buffer(new Buffer(s, 'hex'));
    };

    WordArray.from_hex_le = function(s) {
      return WordArray.from_buffer_le(new Buffer(s, 'hex'));
    };

    WordArray.from_ui8a = function(v) {
      return WordArray.from_buffer(ui8a_to_buffer(v));
    };

    WordArray.from_i32a = function(v) {
      return new WordArray(Array.apply([], v));
    };

    WordArray.prototype.equal = function(wa) {
      var i, ret, w, _i, _len, _ref;
      ret = true;
      if (wa.sigBytes !== this.sigBytes) {
        ret = false;
      } else {
        _ref = this.words;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          w = _ref[i];
          if (util.fixup_uint32(w) !== util.fixup_uint32(wa.words[i])) {
            ret = false;
          }
        }
      }
      return ret;
    };

    WordArray.prototype.xor = function(wa2, _arg) {
      var dst_offset, i, n_words, src_offset, tmp, _i;
      dst_offset = _arg.dst_offset, src_offset = _arg.src_offset, n_words = _arg.n_words;
      if (!dst_offset) {
        dst_offset = 0;
      }
      if (!src_offset) {
        src_offset = 0;
      }
      if (n_words == null) {
        n_words = wa2.words.length - src_offset;
      }
      if (this.words.length < dst_offset + n_words) {
        throw new Error("dest range exceeded (" + this.words.length + " < " + (dst_offset + n_words) + ")");
      }
      if (wa2.words.length < src_offset + n_words) {
        throw new Error("source range exceeded");
      }
      for (i = _i = 0; 0 <= n_words ? _i < n_words : _i > n_words; i = 0 <= n_words ? ++_i : --_i) {
        tmp = this.words[dst_offset + i] ^ wa2.words[src_offset + i];
        this.words[dst_offset + i] = util.fixup_uint32(tmp);
      }
      return this;
    };

    WordArray.prototype.truncate = function(n_bytes) {
      var n_words;
      if (!(n_bytes <= this.sigBytes)) {
        throw new Error("Cannot truncate: " + n_bytes + " > " + this.sigBytes);
      }
      n_words = Math.ceil(n_bytes / 4);
      return new WordArray(this.words.slice(0, n_words), n_bytes);
    };

    WordArray.prototype.unshift = function(n_words) {
      var ret;
      if (this.words.length >= n_words) {
        ret = this.words.splice(0, n_words);
        this.sigBytes -= n_words * 4;
        return new WordArray(ret);
      } else {
        return null;
      }
    };

    WordArray.prototype.is_scrubbed = function() {
      var w, _i, _len, _ref;
      _ref = this.words;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        if (w !== 0) {
          return false;
        }
      }
      return true;
    };

    WordArray.prototype.scrub = function() {
      return util.scrub_vec(this.words);
    };

    WordArray.prototype.slice = function(low, hi) {
      var n, sb;
      n = this.words.length;
      if (!((low < hi) && (hi <= n))) {
        throw new Error("Bad WordArray slice [" + low + "," + hi + ")] when only " + n + " avail");
      }
      sb = (hi - low) * 4;
      if (hi === n) {
        sb -= n * 4 - this.sigBytes;
      }
      return new WordArray(this.words.slice(low, hi), sb);
    };

    return WordArray;

  })();

  exports.X64Word = X64Word = (function() {
    function X64Word(high, low) {
      this.high = high;
      this.low = low;
    }

    X64Word.prototype.clone = function() {
      return new X64Word(this.high, this.low);
    };

    return X64Word;

  })();

  exports.X64WordArray = X64WordArray = (function() {
    function X64WordArray(words, sigBytes) {
      this.sigBytes = sigBytes;
      this.words = words || [];
      if (!this.sigBytes) {
        this.sigBytes = this.words.length * 8;
      }
    }

    X64WordArray.prototype.toX32 = function() {
      var v, w, _i, _len, _ref;
      v = [];
      _ref = this.words;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        v.push(w.high);
        v.push(w.low);
      }
      return new WordArray(v, this.sigBytes);
    };

    X64WordArray.prototype.clone = function() {
      var w;
      return new X64WordArray((function() {
        var _i, _len, _ref, _results;
        _ref = this.words;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w = _ref[_i];
          _results.push(w.clone());
        }
        return _results;
      }).call(this), this.sigBytes);
    };

    return X64WordArray;

  })();

  exports.buffer_to_ui8a = buffer_to_ui8a;

  exports.ui8a_to_buffer = ui8a_to_buffer;

  exports.endian_reverse = endian_reverse;

}).call(this);

},{"./util":28,"__browserify_Buffer":3}],30:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var BaseError, Canceler, EscErr, EscOk, c_to_camel, ipush, make_error_klass, make_errors, make_esc, to_lower, util,
    __slice = [].slice;



  util = require('util');

  exports.BaseError = BaseError = function(msg, constructor) {
    Error.captureStackTrace(this, this.constructor);
    return this.message = msg || 'Error';
  };

  util.inherits(BaseError, Error);

  BaseError.prototype.name = "BaseError";

  to_lower = function(s) {
    return s[0].toUpperCase() + s.slice(1).toLowerCase();
  };

  c_to_camel = function(s) {
    var p;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = s.split(/_/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(to_lower(p));
      }
      return _results;
    })()).join('');
  };

  make_error_klass = function(k, code, default_msg) {
    var ctor;
    ctor = function(msg) {
      BaseError.call(this, msg || default_msg, this.constructor);
      this.istack = [];
      this.code = code;
      return this;
    };
    util.inherits(ctor, BaseError);
    ctor.prototype.name = k;
    ctor.prototype.inspect = function() {
      return "[" + k + ": " + this.message + " (code " + this.code + ")]";
    };
    return ctor;
  };

  exports.make_errors = make_errors = function(d) {
    var enam, errno, k, msg, out, val;
    out = {
      msg: {},
      name: {},
      code: {}
    };
    d.OK = "Success";
    errno = 100;
    for (k in d) {
      msg = d[k];
      if (k !== "OK") {
        enam = (c_to_camel(k)) + "Error";
        val = errno++;
        out[enam] = make_error_klass(enam, val, msg);
      } else {
        val = 0;
      }
      out[k] = val;
      out.msg[k] = out.msg[val] = msg;
      out.name[k] = out.name[val] = k;
      out.code[k] = val;
    }
    return out;
  };

  ipush = function(e, msg) {
    if (msg != null) {
      if (e.istack == null) {
        e.istack = [];
      }
      return e.istack.push(msg);
    }
  };

  exports.make_esc = make_esc = function(gcb, where) {
    return function(lcb) {
      return function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err == null) {
          return lcb.apply(null, args);
        } else if (!gcb.__esc) {
          gcb.__esc = true;
          ipush(err, where);
          return gcb(err);
        }
      };
    };
  };

  exports.EscOk = EscOk = (function() {
    function EscOk(gcb, where) {
      this.gcb = gcb;
      this.where = where;
    }

    EscOk.prototype.bailout = function() {
      var t;
      if (this.gcb) {
        t = this.gcb;
        this.gcb = null;
        return t(false);
      }
    };

    EscOk.prototype.check_ok = function(cb) {
      var _this = this;
      return function() {
        var args, ok;
        ok = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (!ok) {
          return _this.bailout();
        } else {
          return cb.apply(null, args);
        }
      };
    };

    EscOk.prototype.check_err = function(cb) {
      var _this = this;
      return function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err != null) {
          ipush(err, _this.where);
          return _this.bailout();
        } else {
          return cb.apply(null, args);
        }
      };
    };

    EscOk.prototype.check_non_null = function(cb) {
      var _this = this;
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (args[0] == null) {
          return _this.bailout();
        } else {
          return cb.apply(null, args);
        }
      };
    };

    return EscOk;

  })();

  exports.EscErr = EscErr = (function() {
    function EscErr(gcb, where) {
      this.gcb = gcb;
      this.where = where;
    }

    EscErr.prototype.finish = function(err) {
      var t;
      if (this.gcb) {
        t = this.gcb;
        this.gcb = null;
        return t(err);
      }
    };

    EscErr.prototype.check_ok = function(cb, eclass, emsg) {
      if (eclass == null) {
        eclass = Error;
      }
      if (emsg == null) {
        emsg = null;
      }
      return function() {
        var args, err, ok;
        ok = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (!ok) {
          err = new eclass(emsg);
          ipush(err, this.where);
          return this.finish(err);
        } else {
          return cb.apply(null, args);
        }
      };
    };

    EscErr.prototype.check_err = function(cb) {
      return function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err != null) {
          ipush(err, this.where);
          return this.finish(err);
        } else {
          return cb.apply(null, args);
        }
      };
    };

    return EscErr;

  })();

  exports.Canceler = Canceler = (function() {
    function Canceler(klass) {
      this.klass = klass != null ? klass : Error;
      this._canceled = false;
    }

    Canceler.prototype.is_canceled = function() {
      return this._canceled;
    };

    Canceler.prototype.is_ok = function() {
      return !this._canceled;
    };

    Canceler.prototype.cancel = function() {
      return this._canceled = true;
    };

    Canceler.prototype.err = function() {
      if (this._canceled) {
        return new this.klass("Aborted");
      } else {
        return null;
      }
    };

    return Canceler;

  })();

}).call(this);

/*
//@ sourceMappingURL=index.map
*/

},{"util":2}],31:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Generator, iced, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  Generator = Generator = (function() {
    function Generator(opts) {
      opts = opts || {};
      this.loop_delay = opts.loop_delay || 10;
      this.work_min = opts.work_min || 1;
      this.auto_stop_bits = opts.auto_stop_bits || 4096;
      this.max_bits_per_delta = opts.max_bits_per_delta || 4;
      this.entropies = [];
      this.running = true;
      this.timer_race_loop();
    }

    Generator.prototype.generate = function(bits_wanted, cb) {
      var e, harvested_bits, res, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      harvested_bits = 0;
      res = [];
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(harvested_bits < bits_wanted)) {
            return _break();
          } else {
            (function(__iced_k) {
              if (_this.entropies.length) {
                e = _this.entropies.splice(0, 1)[0];
                harvested_bits += e[1];
                return __iced_k(res.push(e[0]));
              } else {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/generator.iced",
                    funcname: "Generator.generate"
                  });
                  setTimeout(__iced_deferrals.defer({
                    lineno: 22
                  }), _this.loop_delay);
                  __iced_deferrals._fulfill();
                })(__iced_k);
              }
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(res);
      });
    };

    Generator.prototype.stop = function() {
      return this.running = false;
    };

    Generator.prototype.resume = function() {
      return this.running = true;
    };

    Generator.prototype.reset = function() {
      this.entropies = [];
      return this.total_bits = 0;
    };

    Generator.prototype.count_unused_bits = function() {
      var bits, e, _i, _len, _ref;
      bits = 0;
      _ref = this.entropies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        bits += e[1];
      }
      return bits;
    };

    Generator.prototype.timer_race_loop = function() {
      var count, delta, entropy, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _results, _while,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this._last_count = null;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!true) {
          return _break();
        } else {
          if (_this.running && (_this.count_unused_bits() < _this.auto_stop_bits)) {
            count = _this.millisecond_count();
            if ((_this._last_count != null) && (delta = count - _this._last_count)) {
              entropy = Math.floor(_this.log_2(Math.abs(delta)));
              entropy = Math.min(_this.max_bits_per_delta, entropy);
              v = [delta, entropy];
              _this.entropies.push(v);
            }
            _this._last_count = count;
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/generator.iced",
              funcname: "Generator.timer_race_loop"
            });
            setTimeout(__iced_deferrals.defer({
              lineno: 48
            }), _this.loop_delay);
            __iced_deferrals._fulfill();
          })(_next);
        }
      };
      _while(__iced_k);
    };

    Generator.prototype.log_2 = function(x) {
      return Math.log(x) / Math.LN2;
    };

    Generator.prototype.millisecond_count = function() {
      var d, i, x;
      d = Date.now();
      i = x = 0;
      while (Date.now() < d + this.work_min + 1) {
        i++;
        x = Math.sin(Math.sqrt(Math.log(i + x)));
      }
      return i;
    };

    return Generator;

  })();

  if (typeof window !== "undefined" && window !== null) {
    window.Generator = Generator;
  }

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Generator = Generator;
  }

}).call(this);

},{"iced-coffee-script/lib/coffee-script/iced":5}],32:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {


  exports.Generator = require('../lib/generator').Generator;

}).call(this);

},{"../lib/generator":31}],33:[function(require,module,exports){

exports.scrypt = require('triplesec').scrypt;
exports.generate = require('keybase-bitcoin').generate;
},{"keybase-bitcoin":6,"triplesec":17}]},{},[33])
(33)
});
;
</script>

<style>
/*!
 * Bootstrap v3.0.2
 *
 * Copyright 2013 Twitter, Inc
 * Licensed under the Apache License v2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Designed and built with all the love in the world @twitter by @mdo and @fat.
 */


article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block;}
audio,canvas,video{display:inline-block;}
audio:not([controls]){display:none;height:0;}
[hidden],template{display:none;}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}
body{margin:0;}
a{background:transparent;}
a:focus{outline:thin dotted;}
a:active,a:hover{outline:0;}
h1{font-size:2em;margin:0.67em 0;}
abbr[title]{border-bottom:1px dotted;}
b,strong{font-weight:bold;}
dfn{font-style:italic;}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0;}
mark{background:#ff0;color:#000;}
code,kbd,pre,samp{font-family:monospace, serif;font-size:1em;}
pre{white-space:pre-wrap;}
q{quotes:"\201C" "\201D" "\2018" "\2019";}
small{font-size:80%;}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}
sup{top:-0.5em;}
sub{bottom:-0.25em;}
img{border:0;}
svg:not(:root){overflow:hidden;}
figure{margin:0;}
fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em;}
legend{border:0;padding:0;}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0;}
button,input{line-height:normal;}
button,select{text-transform:none;}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer;}
button[disabled],html input[disabled]{cursor:default;}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0;}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box;}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none;}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}
textarea{overflow:auto;vertical-align:top;}
table{border-collapse:collapse;border-spacing:0;}
@media print{*{text-shadow:none !important;color:#000 !important;background:transparent !important;box-shadow:none !important;} a,a:visited{text-decoration:underline;} a[href]:after{content:" (" attr(href) ")";} abbr[title]:after{content:" (" attr(title) ")";} a[href^="javascript:"]:after,a[href^="#"]:after{content:"";} pre,blockquote{border:1px solid #999;page-break-inside:avoid;} thead{display:table-header-group;} tr,img{page-break-inside:avoid;} img{max-width:100% !important;} @page {margin:2cm .5cm;}p,h2,h3{orphans:3;widows:3;} h2,h3{page-break-after:avoid;} select{background:#fff !important;} .navbar{display:none;} .table td,.table th{background-color:#fff !important;} .btn>.caret,.dropup>.btn>.caret{border-top-color:#000 !important;} .label{border:1px solid #000;} .table{border-collapse:collapse !important;} .table-bordered th,.table-bordered td{border:1px solid #ddd !important;}}*,*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;}
html{font-size:62.5%;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);}
body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.428571429;color:#333333;background-color:#ffffff;}
input,button,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit;}
a{color:#428bca;text-decoration:none;}a:hover,a:focus{color:#2a6496;text-decoration:underline;}
a:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px;}
img{vertical-align:middle;}
.img-responsive{display:block;max-width:100%;height:auto;}
.img-rounded{border-radius:6px;}
.img-thumbnail{padding:4px;line-height:1.428571429;background-color:#ffffff;border:1px solid #dddddd;border-radius:4px;-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out;display:inline-block;max-width:100%;height:auto;}
.img-circle{border-radius:50%;}
hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eeeeee;}
.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);border:0;}
p{margin:0 0 10px;}
.lead{margin-bottom:20px;font-size:16px;font-weight:200;line-height:1.4;}@media (min-width:768px){.lead{font-size:21px;}}
small,.small{font-size:85%;}
cite{font-style:normal;}
.text-muted{color:#999999;}
.text-primary{color:#428bca;}.text-primary:hover{color:#3071a9;}
.text-warning{color:#c09853;}.text-warning:hover{color:#a47e3c;}
.text-danger{color:#b94a48;}.text-danger:hover{color:#953b39;}
.text-success{color:#468847;}.text-success:hover{color:#356635;}
.text-info{color:#3a87ad;}.text-info:hover{color:#2d6987;}
.text-left{text-align:left;}
.text-right{text-align:right;}
.text-center{text-align:center;}
h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:500;line-height:1.1;color:inherit;}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small,.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 .small,h2 .small,h3 .small,h4 .small,h5 .small,h6 .small,.h1 .small,.h2 .small,.h3 .small,.h4 .small,.h5 .small,.h6 .small{font-weight:normal;line-height:1;color:#999999;}
h1,h2,h3{margin-top:20px;margin-bottom:10px;}h1 small,h2 small,h3 small,h1 .small,h2 .small,h3 .small{font-size:65%;}
h4,h5,h6{margin-top:10px;margin-bottom:10px;}h4 small,h5 small,h6 small,h4 .small,h5 .small,h6 .small{font-size:75%;}
h1,.h1{font-size:36px;}
h2,.h2{font-size:30px;}
h3,.h3{font-size:24px;}
h4,.h4{font-size:18px;}
h5,.h5{font-size:14px;}
h6,.h6{font-size:12px;}
.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eeeeee;}
ul,ol{margin-top:0;margin-bottom:10px;}ul ul,ol ul,ul ol,ol ol{margin-bottom:0;}
.list-unstyled{padding-left:0;list-style:none;}
.list-inline{padding-left:0;list-style:none;}.list-inline>li{display:inline-block;padding-left:5px;padding-right:5px;}.list-inline>li:first-child{padding-left:0;}
dl{margin-bottom:20px;}
dt,dd{line-height:1.428571429;}
dt{font-weight:bold;}
dd{margin-left:0;}
@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;clear:left;text-align:right;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;} .dl-horizontal dd{margin-left:180px;}.dl-horizontal dd:before,.dl-horizontal dd:after{content:" ";display:table;} .dl-horizontal dd:after{clear:both;}}abbr[title],abbr[data-original-title]{cursor:help;border-bottom:1px dotted #999999;}
abbr.initialism{font-size:90%;text-transform:uppercase;}
blockquote{padding:10px 20px;margin:0 0 20px;border-left:5px solid #eeeeee;}blockquote p{font-size:17.5px;font-weight:300;line-height:1.25;}
blockquote p:last-child{margin-bottom:0;}
blockquote small{display:block;line-height:1.428571429;color:#999999;}blockquote small:before{content:'\2014 \00A0';}
blockquote.pull-right{padding-right:15px;padding-left:0;border-right:5px solid #eeeeee;border-left:0;}blockquote.pull-right p,blockquote.pull-right small,blockquote.pull-right .small{text-align:right;}
blockquote.pull-right small:before,blockquote.pull-right .small:before{content:'';}
blockquote.pull-right small:after,blockquote.pull-right .small:after{content:'\00A0 \2014';}
blockquote:before,blockquote:after{content:"";}
address{margin-bottom:20px;font-style:normal;line-height:1.428571429;}
code,kbd,pre,samp{font-family:Monaco,Menlo,Consolas,"Courier New",monospace;}
code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;white-space:nowrap;border-radius:4px;}
pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.428571429;word-break:break-all;word-wrap:break-word;color:#333333;background-color:#f5f5f5;border:1px solid #cccccc;border-radius:4px;}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0;}
.pre-scrollable{max-height:340px;overflow-y:scroll;}
.container{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px;}.container:before,.container:after{content:" ";display:table;}
.container:after{clear:both;}
.row{margin-left:-15px;margin-right:-15px;}.row:before,.row:after{content:" ";display:table;}
.row:after{clear:both;}
.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12{position:relative;min-height:1px;padding-left:15px;padding-right:15px;}
.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11{float:left;}
.col-xs-12{width:100%;}
.col-xs-11{width:91.66666666666666%;}
.col-xs-10{width:83.33333333333334%;}
.col-xs-9{width:75%;}
.col-xs-8{width:66.66666666666666%;}
.col-xs-7{width:58.333333333333336%;}
.col-xs-6{width:50%;}
.col-xs-5{width:41.66666666666667%;}
.col-xs-4{width:33.33333333333333%;}
.col-xs-3{width:25%;}
.col-xs-2{width:16.666666666666664%;}
.col-xs-1{width:8.333333333333332%;}
.col-xs-pull-12{right:100%;}
.col-xs-pull-11{right:91.66666666666666%;}
.col-xs-pull-10{right:83.33333333333334%;}
.col-xs-pull-9{right:75%;}
.col-xs-pull-8{right:66.66666666666666%;}
.col-xs-pull-7{right:58.333333333333336%;}
.col-xs-pull-6{right:50%;}
.col-xs-pull-5{right:41.66666666666667%;}
.col-xs-pull-4{right:33.33333333333333%;}
.col-xs-pull-3{right:25%;}
.col-xs-pull-2{right:16.666666666666664%;}
.col-xs-pull-1{right:8.333333333333332%;}
.col-xs-pull-0{right:0%;}
.col-xs-push-12{left:100%;}
.col-xs-push-11{left:91.66666666666666%;}
.col-xs-push-10{left:83.33333333333334%;}
.col-xs-push-9{left:75%;}
.col-xs-push-8{left:66.66666666666666%;}
.col-xs-push-7{left:58.333333333333336%;}
.col-xs-push-6{left:50%;}
.col-xs-push-5{left:41.66666666666667%;}
.col-xs-push-4{left:33.33333333333333%;}
.col-xs-push-3{left:25%;}
.col-xs-push-2{left:16.666666666666664%;}
.col-xs-push-1{left:8.333333333333332%;}
.col-xs-push-0{left:0%;}
.col-xs-offset-12{margin-left:100%;}
.col-xs-offset-11{margin-left:91.66666666666666%;}
.col-xs-offset-10{margin-left:83.33333333333334%;}
.col-xs-offset-9{margin-left:75%;}
.col-xs-offset-8{margin-left:66.66666666666666%;}
.col-xs-offset-7{margin-left:58.333333333333336%;}
.col-xs-offset-6{margin-left:50%;}
.col-xs-offset-5{margin-left:41.66666666666667%;}
.col-xs-offset-4{margin-left:33.33333333333333%;}
.col-xs-offset-3{margin-left:25%;}
.col-xs-offset-2{margin-left:16.666666666666664%;}
.col-xs-offset-1{margin-left:8.333333333333332%;}
.col-xs-offset-0{margin-left:0%;}
@media (min-width:768px){.container{width:750px;} .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11{float:left;} .col-sm-12{width:100%;} .col-sm-11{width:91.66666666666666%;} .col-sm-10{width:83.33333333333334%;} .col-sm-9{width:75%;} .col-sm-8{width:66.66666666666666%;} .col-sm-7{width:58.333333333333336%;} .col-sm-6{width:50%;} .col-sm-5{width:41.66666666666667%;} .col-sm-4{width:33.33333333333333%;} .col-sm-3{width:25%;} .col-sm-2{width:16.666666666666664%;} .col-sm-1{width:8.333333333333332%;} .col-sm-pull-12{right:100%;} .col-sm-pull-11{right:91.66666666666666%;} .col-sm-pull-10{right:83.33333333333334%;} .col-sm-pull-9{right:75%;} .col-sm-pull-8{right:66.66666666666666%;} .col-sm-pull-7{right:58.333333333333336%;} .col-sm-pull-6{right:50%;} .col-sm-pull-5{right:41.66666666666667%;} .col-sm-pull-4{right:33.33333333333333%;} .col-sm-pull-3{right:25%;} .col-sm-pull-2{right:16.666666666666664%;} .col-sm-pull-1{right:8.333333333333332%;} .col-sm-pull-0{right:0%;} .col-sm-push-12{left:100%;} .col-sm-push-11{left:91.66666666666666%;} .col-sm-push-10{left:83.33333333333334%;} .col-sm-push-9{left:75%;} .col-sm-push-8{left:66.66666666666666%;} .col-sm-push-7{left:58.333333333333336%;} .col-sm-push-6{left:50%;} .col-sm-push-5{left:41.66666666666667%;} .col-sm-push-4{left:33.33333333333333%;} .col-sm-push-3{left:25%;} .col-sm-push-2{left:16.666666666666664%;} .col-sm-push-1{left:8.333333333333332%;} .col-sm-push-0{left:0%;} .col-sm-offset-12{margin-left:100%;} .col-sm-offset-11{margin-left:91.66666666666666%;} .col-sm-offset-10{margin-left:83.33333333333334%;} .col-sm-offset-9{margin-left:75%;} .col-sm-offset-8{margin-left:66.66666666666666%;} .col-sm-offset-7{margin-left:58.333333333333336%;} .col-sm-offset-6{margin-left:50%;} .col-sm-offset-5{margin-left:41.66666666666667%;} .col-sm-offset-4{margin-left:33.33333333333333%;} .col-sm-offset-3{margin-left:25%;} .col-sm-offset-2{margin-left:16.666666666666664%;} .col-sm-offset-1{margin-left:8.333333333333332%;} .col-sm-offset-0{margin-left:0%;}}@media (min-width:992px){.container{width:970px;} .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11{float:left;} .col-md-12{width:100%;} .col-md-11{width:91.66666666666666%;} .col-md-10{width:83.33333333333334%;} .col-md-9{width:75%;} .col-md-8{width:66.66666666666666%;} .col-md-7{width:58.333333333333336%;} .col-md-6{width:50%;} .col-md-5{width:41.66666666666667%;} .col-md-4{width:33.33333333333333%;} .col-md-3{width:25%;} .col-md-2{width:16.666666666666664%;} .col-md-1{width:8.333333333333332%;} .col-md-pull-12{right:100%;} .col-md-pull-11{right:91.66666666666666%;} .col-md-pull-10{right:83.33333333333334%;} .col-md-pull-9{right:75%;} .col-md-pull-8{right:66.66666666666666%;} .col-md-pull-7{right:58.333333333333336%;} .col-md-pull-6{right:50%;} .col-md-pull-5{right:41.66666666666667%;} .col-md-pull-4{right:33.33333333333333%;} .col-md-pull-3{right:25%;} .col-md-pull-2{right:16.666666666666664%;} .col-md-pull-1{right:8.333333333333332%;} .col-md-pull-0{right:0%;} .col-md-push-12{left:100%;} .col-md-push-11{left:91.66666666666666%;} .col-md-push-10{left:83.33333333333334%;} .col-md-push-9{left:75%;} .col-md-push-8{left:66.66666666666666%;} .col-md-push-7{left:58.333333333333336%;} .col-md-push-6{left:50%;} .col-md-push-5{left:41.66666666666667%;} .col-md-push-4{left:33.33333333333333%;} .col-md-push-3{left:25%;} .col-md-push-2{left:16.666666666666664%;} .col-md-push-1{left:8.333333333333332%;} .col-md-push-0{left:0%;} .col-md-offset-12{margin-left:100%;} .col-md-offset-11{margin-left:91.66666666666666%;} .col-md-offset-10{margin-left:83.33333333333334%;} .col-md-offset-9{margin-left:75%;} .col-md-offset-8{margin-left:66.66666666666666%;} .col-md-offset-7{margin-left:58.333333333333336%;} .col-md-offset-6{margin-left:50%;} .col-md-offset-5{margin-left:41.66666666666667%;} .col-md-offset-4{margin-left:33.33333333333333%;} .col-md-offset-3{margin-left:25%;} .col-md-offset-2{margin-left:16.666666666666664%;} .col-md-offset-1{margin-left:8.333333333333332%;} .col-md-offset-0{margin-left:0%;}}@media (min-width:1200px){.container{width:1170px;} .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11{float:left;} .col-lg-12{width:100%;} .col-lg-11{width:91.66666666666666%;} .col-lg-10{width:83.33333333333334%;} .col-lg-9{width:75%;} .col-lg-8{width:66.66666666666666%;} .col-lg-7{width:58.333333333333336%;} .col-lg-6{width:50%;} .col-lg-5{width:41.66666666666667%;} .col-lg-4{width:33.33333333333333%;} .col-lg-3{width:25%;} .col-lg-2{width:16.666666666666664%;} .col-lg-1{width:8.333333333333332%;} .col-lg-pull-12{right:100%;} .col-lg-pull-11{right:91.66666666666666%;} .col-lg-pull-10{right:83.33333333333334%;} .col-lg-pull-9{right:75%;} .col-lg-pull-8{right:66.66666666666666%;} .col-lg-pull-7{right:58.333333333333336%;} .col-lg-pull-6{right:50%;} .col-lg-pull-5{right:41.66666666666667%;} .col-lg-pull-4{right:33.33333333333333%;} .col-lg-pull-3{right:25%;} .col-lg-pull-2{right:16.666666666666664%;} .col-lg-pull-1{right:8.333333333333332%;} .col-lg-pull-0{right:0%;} .col-lg-push-12{left:100%;} .col-lg-push-11{left:91.66666666666666%;} .col-lg-push-10{left:83.33333333333334%;} .col-lg-push-9{left:75%;} .col-lg-push-8{left:66.66666666666666%;} .col-lg-push-7{left:58.333333333333336%;} .col-lg-push-6{left:50%;} .col-lg-push-5{left:41.66666666666667%;} .col-lg-push-4{left:33.33333333333333%;} .col-lg-push-3{left:25%;} .col-lg-push-2{left:16.666666666666664%;} .col-lg-push-1{left:8.333333333333332%;} .col-lg-push-0{left:0%;} .col-lg-offset-12{margin-left:100%;} .col-lg-offset-11{margin-left:91.66666666666666%;} .col-lg-offset-10{margin-left:83.33333333333334%;} .col-lg-offset-9{margin-left:75%;} .col-lg-offset-8{margin-left:66.66666666666666%;} .col-lg-offset-7{margin-left:58.333333333333336%;} .col-lg-offset-6{margin-left:50%;} .col-lg-offset-5{margin-left:41.66666666666667%;} .col-lg-offset-4{margin-left:33.33333333333333%;} .col-lg-offset-3{margin-left:25%;} .col-lg-offset-2{margin-left:16.666666666666664%;} .col-lg-offset-1{margin-left:8.333333333333332%;} .col-lg-offset-0{margin-left:0%;}}table{max-width:100%;background-color:transparent;}
th{text-align:left;}
.table{width:100%;margin-bottom:20px;}.table>thead>tr>th,.table>tbody>tr>th,.table>tfoot>tr>th,.table>thead>tr>td,.table>tbody>tr>td,.table>tfoot>tr>td{padding:8px;line-height:1.428571429;vertical-align:top;border-top:1px solid #dddddd;}
.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #dddddd;}
.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>th,.table>caption+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>td,.table>thead:first-child>tr:first-child>td{border-top:0;}
.table>tbody+tbody{border-top:2px solid #dddddd;}
.table .table{background-color:#ffffff;}
.table-condensed>thead>tr>th,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>tbody>tr>td,.table-condensed>tfoot>tr>td{padding:5px;}
.table-bordered{border:1px solid #dddddd;}.table-bordered>thead>tr>th,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>tbody>tr>td,.table-bordered>tfoot>tr>td{border:1px solid #dddddd;}
.table-bordered>thead>tr>th,.table-bordered>thead>tr>td{border-bottom-width:2px;}
.table-striped>tbody>tr:nth-child(odd)>td,.table-striped>tbody>tr:nth-child(odd)>th{background-color:#f9f9f9;}
.table-hover>tbody>tr:hover>td,.table-hover>tbody>tr:hover>th{background-color:#f5f5f5;}
table col[class*="col-"]{float:none;display:table-column;}
table td[class*="col-"],table th[class*="col-"]{float:none;display:table-cell;}
.table>thead>tr>td.active,.table>tbody>tr>td.active,.table>tfoot>tr>td.active,.table>thead>tr>th.active,.table>tbody>tr>th.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>tbody>tr.active>td,.table>tfoot>tr.active>td,.table>thead>tr.active>th,.table>tbody>tr.active>th,.table>tfoot>tr.active>th{background-color:#f5f5f5;}
.table>thead>tr>td.success,.table>tbody>tr>td.success,.table>tfoot>tr>td.success,.table>thead>tr>th.success,.table>tbody>tr>th.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>tbody>tr.success>td,.table>tfoot>tr.success>td,.table>thead>tr.success>th,.table>tbody>tr.success>th,.table>tfoot>tr.success>th{background-color:#dff0d8;}
.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover,.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th{background-color:#d0e9c6;}
.table>thead>tr>td.danger,.table>tbody>tr>td.danger,.table>tfoot>tr>td.danger,.table>thead>tr>th.danger,.table>tbody>tr>th.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>tbody>tr.danger>td,.table>tfoot>tr.danger>td,.table>thead>tr.danger>th,.table>tbody>tr.danger>th,.table>tfoot>tr.danger>th{background-color:#f2dede;}
.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover,.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th{background-color:#ebcccc;}
.table>thead>tr>td.warning,.table>tbody>tr>td.warning,.table>tfoot>tr>td.warning,.table>thead>tr>th.warning,.table>tbody>tr>th.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>tbody>tr.warning>td,.table>tfoot>tr.warning>td,.table>thead>tr.warning>th,.table>tbody>tr.warning>th,.table>tfoot>tr.warning>th{background-color:#fcf8e3;}
.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover,.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th{background-color:#faf2cc;}
@media (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;overflow-x:scroll;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #dddddd;-webkit-overflow-scrolling:touch;}.table-responsive>.table{margin-bottom:0;}.table-responsive>.table>thead>tr>th,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tfoot>tr>td{white-space:nowrap;} .table-responsive>.table-bordered{border:0;}.table-responsive>.table-bordered>thead>tr>th:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child{border-left:0;} .table-responsive>.table-bordered>thead>tr>th:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child{border-right:0;} .table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>th,.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>td{border-bottom:0;}}fieldset{padding:0;margin:0;border:0;}
legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333333;border:0;border-bottom:1px solid #e5e5e5;}
label{display:inline-block;margin-bottom:5px;font-weight:bold;}
input[type="search"]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;}
input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;line-height:normal;}
input[type="file"]{display:block;}
select[multiple],select[size]{height:auto;}
select optgroup{font-size:inherit;font-style:inherit;font-family:inherit;}
input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px;}
input[type="number"]::-webkit-outer-spin-button,input[type="number"]::-webkit-inner-spin-button{height:auto;}
output{display:block;padding-top:7px;font-size:14px;line-height:1.428571429;color:#555555;vertical-align:middle;}
.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.428571429;color:#555555;vertical-align:middle;background-color:#ffffff;background-image:none;border:1px solid #cccccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);-webkit-transition:border-color ease-in-out .15s, box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s, box-shadow ease-in-out .15s;}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);}
.form-control:-moz-placeholder{color:#999999;}
.form-control::-moz-placeholder{color:#999999;}
.form-control:-ms-input-placeholder{color:#999999;}
.form-control::-webkit-input-placeholder{color:#999999;}
.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{cursor:not-allowed;background-color:#eeeeee;}
textarea.form-control{height:auto;}
.form-group{margin-bottom:15px;}
.radio,.checkbox{display:block;min-height:20px;margin-top:10px;margin-bottom:10px;padding-left:20px;vertical-align:middle;}.radio label,.checkbox label{display:inline;margin-bottom:0;font-weight:normal;cursor:pointer;}
.radio input[type="radio"],.radio-inline input[type="radio"],.checkbox input[type="checkbox"],.checkbox-inline input[type="checkbox"]{float:left;margin-left:-20px;}
.radio+.radio,.checkbox+.checkbox{margin-top:-5px;}
.radio-inline,.checkbox-inline{display:inline-block;padding-left:20px;margin-bottom:0;vertical-align:middle;font-weight:normal;cursor:pointer;}
.radio-inline+.radio-inline,.checkbox-inline+.checkbox-inline{margin-top:0;margin-left:10px;}
input[type="radio"][disabled],input[type="checkbox"][disabled],.radio[disabled],.radio-inline[disabled],.checkbox[disabled],.checkbox-inline[disabled],fieldset[disabled] input[type="radio"],fieldset[disabled] input[type="checkbox"],fieldset[disabled] .radio,fieldset[disabled] .radio-inline,fieldset[disabled] .checkbox,fieldset[disabled] .checkbox-inline{cursor:not-allowed;}
.input-sm{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px;}select.input-sm{height:30px;line-height:30px;}
textarea.input-sm{height:auto;}
.input-lg{height:45px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px;}select.input-lg{height:45px;line-height:45px;}
textarea.input-lg{height:auto;}
.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline{color:#c09853;}
.has-warning .form-control{border-color:#c09853;-webkit-box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);}.has-warning .form-control:focus{border-color:#a47e3c;-webkit-box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 6px #dbc59e;box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 6px #dbc59e;}
.has-warning .input-group-addon{color:#c09853;border-color:#c09853;background-color:#fcf8e3;}
.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline{color:#b94a48;}
.has-error .form-control{border-color:#b94a48;-webkit-box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);}.has-error .form-control:focus{border-color:#953b39;-webkit-box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 6px #d59392;box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 6px #d59392;}
.has-error .input-group-addon{color:#b94a48;border-color:#b94a48;background-color:#f2dede;}
.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline{color:#468847;}
.has-success .form-control{border-color:#468847;-webkit-box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075);}.has-success .form-control:focus{border-color:#356635;-webkit-box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 6px #7aba7b;box-shadow:inset 0 1px 1px rgba(0, 0, 0, 0.075),0 0 6px #7aba7b;}
.has-success .input-group-addon{color:#468847;border-color:#468847;background-color:#dff0d8;}
.form-control-static{margin-bottom:0;}
.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373;}
@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle;} .form-inline .form-control{display:inline-block;} .form-inline .radio,.form-inline .checkbox{display:inline-block;margin-top:0;margin-bottom:0;padding-left:0;} .form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{float:none;margin-left:0;}}
.form-horizontal .control-label,.form-horizontal .radio,.form-horizontal .checkbox,.form-horizontal .radio-inline,.form-horizontal .checkbox-inline{margin-top:0;margin-bottom:0;padding-top:7px;}
.form-horizontal .form-group{margin-left:-15px;margin-right:-15px;}.form-horizontal .form-group:before,.form-horizontal .form-group:after{content:" ";display:table;}
.form-horizontal .form-group:after{clear:both;}
.form-horizontal .form-control-static{padding-top:7px;}
@media (min-width:768px){.form-horizontal .control-label{text-align:right;}}
.btn{display:inline-block;margin-bottom:0;font-weight:normal;text-align:center;vertical-align:middle;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;padding:6px 12px;font-size:14px;line-height:1.428571429;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px;}
.btn:hover,.btn:focus{color:#333333;text-decoration:none;}
.btn:active,.btn.active{outline:0;background-image:none;-webkit-box-shadow:inset 0 3px 5px rgba(0, 0, 0, 0.125);box-shadow:inset 0 3px 5px rgba(0, 0, 0, 0.125);}
.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;pointer-events:none;opacity:0.65;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;}
.btn-default{color:#333333;background-color:#ffffff;border-color:#cccccc;}.btn-default:hover,.btn-default:focus,.btn-default:active,.btn-default.active,.open .dropdown-toggle.btn-default{color:#333333;background-color:#ebebeb;border-color:#adadad;}
.btn-default:active,.btn-default.active,.open .dropdown-toggle.btn-default{background-image:none;}
.btn-default.disabled,.btn-default[disabled],fieldset[disabled] .btn-default,.btn-default.disabled:hover,.btn-default[disabled]:hover,fieldset[disabled] .btn-default:hover,.btn-default.disabled:focus,.btn-default[disabled]:focus,fieldset[disabled] .btn-default:focus,.btn-default.disabled:active,.btn-default[disabled]:active,fieldset[disabled] .btn-default:active,.btn-default.disabled.active,.btn-default[disabled].active,fieldset[disabled] .btn-default.active{background-color:#ffffff;border-color:#cccccc;}
.btn-primary{color:#ffffff;background-color:#428bca;border-color:#357ebd;}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.open .dropdown-toggle.btn-primary{color:#ffffff;background-color:#3276b1;border-color:#285e8e;}
.btn-primary:active,.btn-primary.active,.open .dropdown-toggle.btn-primary{background-image:none;}
.btn-primary.disabled,.btn-primary[disabled],fieldset[disabled] .btn-primary,.btn-primary.disabled:hover,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary:hover,.btn-primary.disabled:focus,.btn-primary[disabled]:focus,fieldset[disabled] .btn-primary:focus,.btn-primary.disabled:active,.btn-primary[disabled]:active,fieldset[disabled] .btn-primary:active,.btn-primary.disabled.active,.btn-primary[disabled].active,fieldset[disabled] .btn-primary.active{background-color:#428bca;border-color:#357ebd;}
.btn-warning{color:#ffffff;background-color:#f0ad4e;border-color:#eea236;}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.open .dropdown-toggle.btn-warning{color:#ffffff;background-color:#ed9c28;border-color:#d58512;}
.btn-warning:active,.btn-warning.active,.open .dropdown-toggle.btn-warning{background-image:none;}
.btn-warning.disabled,.btn-warning[disabled],fieldset[disabled] .btn-warning,.btn-warning.disabled:hover,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning:hover,.btn-warning.disabled:focus,.btn-warning[disabled]:focus,fieldset[disabled] .btn-warning:focus,.btn-warning.disabled:active,.btn-warning[disabled]:active,fieldset[disabled] .btn-warning:active,.btn-warning.disabled.active,.btn-warning[disabled].active,fieldset[disabled] .btn-warning.active{background-color:#f0ad4e;border-color:#eea236;}
.btn-danger{color:#ffffff;background-color:#d9534f;border-color:#d43f3a;}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.open .dropdown-toggle.btn-danger{color:#ffffff;background-color:#d2322d;border-color:#ac2925;}
.btn-danger:active,.btn-danger.active,.open .dropdown-toggle.btn-danger{background-image:none;}
.btn-danger.disabled,.btn-danger[disabled],fieldset[disabled] .btn-danger,.btn-danger.disabled:hover,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger:hover,.btn-danger.disabled:focus,.btn-danger[disabled]:focus,fieldset[disabled] .btn-danger:focus,.btn-danger.disabled:active,.btn-danger[disabled]:active,fieldset[disabled] .btn-danger:active,.btn-danger.disabled.active,.btn-danger[disabled].active,fieldset[disabled] .btn-danger.active{background-color:#d9534f;border-color:#d43f3a;}
.btn-success{color:#ffffff;background-color:#5cb85c;border-color:#4cae4c;}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.open .dropdown-toggle.btn-success{color:#ffffff;background-color:#47a447;border-color:#398439;}
.btn-success:active,.btn-success.active,.open .dropdown-toggle.btn-success{background-image:none;}
.btn-success.disabled,.btn-success[disabled],fieldset[disabled] .btn-success,.btn-success.disabled:hover,.btn-success[disabled]:hover,fieldset[disabled] .btn-success:hover,.btn-success.disabled:focus,.btn-success[disabled]:focus,fieldset[disabled] .btn-success:focus,.btn-success.disabled:active,.btn-success[disabled]:active,fieldset[disabled] .btn-success:active,.btn-success.disabled.active,.btn-success[disabled].active,fieldset[disabled] .btn-success.active{background-color:#5cb85c;border-color:#4cae4c;}
.btn-info{color:#ffffff;background-color:#5bc0de;border-color:#46b8da;}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.open .dropdown-toggle.btn-info{color:#ffffff;background-color:#39b3d7;border-color:#269abc;}
.btn-info:active,.btn-info.active,.open .dropdown-toggle.btn-info{background-image:none;}
.btn-info.disabled,.btn-info[disabled],fieldset[disabled] .btn-info,.btn-info.disabled:hover,.btn-info[disabled]:hover,fieldset[disabled] .btn-info:hover,.btn-info.disabled:focus,.btn-info[disabled]:focus,fieldset[disabled] .btn-info:focus,.btn-info.disabled:active,.btn-info[disabled]:active,fieldset[disabled] .btn-info:active,.btn-info.disabled.active,.btn-info[disabled].active,fieldset[disabled] .btn-info.active{background-color:#5bc0de;border-color:#46b8da;}
.btn-link{color:#428bca;font-weight:normal;cursor:pointer;border-radius:0;}.btn-link,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none;}
.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active{border-color:transparent;}
.btn-link:hover,.btn-link:focus{color:#2a6496;text-decoration:underline;background-color:transparent;}
.btn-link[disabled]:hover,fieldset[disabled] .btn-link:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:focus{color:#999999;text-decoration:none;}
.btn-lg{padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px;}
.btn-sm,.btn-xs{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px;}
.btn-xs{padding:1px 5px;}
.btn-block{display:block;width:100%;padding-left:0;padding-right:0;}
.btn-block+.btn-block{margin-top:5px;}
input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%;}

</style>

<style>
body {
  font-family: 'helvetica neue', 'helvetica', 'arial';
  background-image: url(data:image/jpeg;base64,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TMo6/wAI7fFMI4Hz/wBSlImNAR30lIzoXaz4JKWgxI17GEgNZ58DqpEwDIjwUZiDpB/iOUlK+Hb708iBH4f3JhqRMx+VKAOdT31+9JSj4x8/9yTp5HwJASjkfgnESB/FJS3xEzqApTBmYA15TAgeZ/14TkDk8niP9iSmPmNI48U3BnsdCFLngacwmEE9teY80lLgE6gJD4nXjyTDsJBCQIidY41SUqefHx0I/kpc/k1S0mRIPjMJSR28+ySl5mA7jyTR8x3TCSeDqpGPikp//9DkDIE8/wCvZN38h93gpTGveJ8E0xHh2Hx8FEzKB07EBIAA6cHw7ym/DxKkBIMkRokpYGPumCkD2+XyTEHsYS4BJ+/zSUrQifnx+CQHbv8AxPmnHbdr5pCY40SUtoRr8BGiQ1dPECJ4T/6/7kpET96SlaaDWB4pASSRxxBTxr4n+Cjz8eNPFJS50Ht8gQkOdYAGspd9NRpJ7paRoAfDw0SUttHYfNKBGvf5pE/CT8EjrrB1SUoEzpqlofDVLTbwmPzJ+CSl+3PBTjx5KRHOqYEgcaDukp//2f/tEMZQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAABxwCAAACAAAAOEJJTQQlAAAAAAAQ6PFc8y/BGKGie2etxWTVujhCSU0D7QAAAAAAEABIAAAAAQABAEgAAAABAAE4QklNBCYAAAAAAA4AAAAAAAAAAAAAP4AAADhCSU0EDQAAAAAABAAAAHg4QklNBBkAAAAAAAQAAAAeOEJJTQPzAAAAAAAJAAAAAAAAAAABADhCSU0ECgAAAAAAAQAAOEJJTScQAAAAAAAKAAEAAAAAAAAAAjhCSU0D9QAAAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+AAAAAAAcAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAA4QklNBAgAAAAAABAAAAABAAACQAAAAkAAAAAAOEJJTQQeAAAAAAAEAAAAADhCSU0EGgAAAAADPwAA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poNYHikBJJHHEFPGvif4KPPx408UlLnQe3yBCQ51gAayl301GknulpGgB8PDRJS20dh80oEa9/mkT8JPwSOusHVJSgTOmqWh8NUtNvCY/Mn4JKX7c8FOPHkpEc6pgSBxoO6Sn//ZOEJJTQQhAAAAAABVAAAAAQEAAAAPAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwAAAAEwBBAGQAbwBiAGUAIABQAGgAbwB0AG8AcwBoAG8AcAAgAEMAUwAzAAAAAQA4QklNBAYAAAAAAAcACAABAAEBAP/hD85odHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDQuMS1jMDM2IDQ2LjI3NjcyMCwgTW9uIEZlYiAxOSAyMDA3IDIyOjQwOjA4ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnhhcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eGFwTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiB4YXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzMgV2luZG93cyIgeGFwOkNyZWF0ZURhdGU9IjIwMTAtMDktMDdUMTY6MDE6NDgtMDU6MDAiIHhhcDpNb2RpZnlEYXRlPSIyMDEwLTA5LTA3VDE2OjM5OjQ0LTA1OjAwIiB4YXA6TWV0YWRhdGFEYXRlPSIyMDEwLTA5LTA3VDE2OjM5OjQ0LTA1OjAwIiB4YXBNTTpEb2N1bWVudElEPSJ1dWlkOjIyN0FFQTBFQzNCQURGMTE5NUUyQ0YyRkYwMURGNkFCIiB4YXBNTTpJbnN0YW5jZUlEPSJ1dWlkOkM2RDdGRjVCQzhCQURGMTFCQkFBRTBBNzAzOURFOEFCIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0iQWRvYmUgUkdCICgxOTk4KSIgcGhvdG9zaG9wOkhpc3Rvcnk9IiIgdGlmZjpPcmllbnRhdGlvbj0iMSIgdGlmZjpYUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOllSZXNvbHV0aW9uPSI3MjAwMDAvMTAwMDAiIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiIHRpZmY6TmF0aXZlRGlnZXN0PSIyNTYsMjU3LDI1OCwyNTksMjYyLDI3NCwyNzcsMjg0LDUzMCw1MzEsMjgyLDI4MywyOTYsMzAxLDMxOCwzMTksNTI5LDUzMiwzMDYsMjcwLDI3MSwyNzIsMzA1LDMxNSwzMzQzMjsxRTg0MUJFQUJBN0MzOEUzQTk4Q0ZBODBENzBGMUM4MiIgZXhpZjpQaXhlbFhEaW1lbnNpb249IjU3NiIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjU3NiIgZXhpZjpDb2xvclNwYWNlPSItMSIgZXhpZjpOYXRpdmVEaWdlc3Q9IjM2ODY0LDQwOTYwLDQwOTYxLDM3MTIxLDM3MTIyLDQwOTYyLDQwOTYzLDM3NTEwLDQwOTY0LDM2ODY3LDM2ODY4LDMzNDM0LDMzNDM3LDM0ODUwLDM0ODUyLDM0ODU1LDM0ODU2LDM3Mzc3LDM3Mzc4LDM3Mzc5LDM3MzgwLDM3MzgxLDM3MzgyLDM3MzgzLDM3Mzg0LDM3Mzg1LDM3Mzg2LDM3Mzk2LDQxNDgzLDQxNDg0LDQxNDg2LDQxNDg3LDQxNDg4LDQxNDkyLDQxNDkzLDQxNDk1LDQxNzI4LDQxNzI5LDQxNzMwLDQxOTg1LDQxOTg2LDQxOTg3LDQxOTg4LDQxOTg5LDQxOTkwLDQxOTkxLDQxOTkyLDQxOTkzLDQxOTk0LDQxOTk1LDQxOTk2LDQyMDE2LDAsMiw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwyMCwyMiwyMywyNCwyNSwyNiwyNywyOCwzMDtDODFBMTM5OTREN0JEOUNDMDIzNjk2NDM0NDlFQzlENyI+IDx4YXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOkE5MkI4MzQ4QzJCQURGMTE5NUUyQ0YyRkYwMURGNkFCIiBzdFJlZjpkb2N1bWVudElEPSJ1dWlkOkE5MkI4MzQ4QzJCQURGMTE5NUUyQ0YyRkYwMURGNkFCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw/eHBhY2tldCBlbmQ9InciPz7/4gJASUNDX1BST0ZJTEUAAQEAAAIwQURCRQIQAABtbnRyUkdCIFhZWiAHzwAGAAMAAAAAAABhY3NwQVBQTAAAAABub25lAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLUFEQkUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApjcHJ0AAAA/AAAADJkZXNjAAABMAAAAGt3dHB0AAABnAAAABRia3B0AAABsAAAABRyVFJDAAABxAAAAA5nVFJDAAAB1AAAAA5iVFJDAAAB5AAA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);
  background-repeat: repeat-x repeat-y;
}
h1 {
  font-size:3em;
  color:#000;
  font-weight:bold;
  text-align: center;
  margin-bottom:30px;
  text-shadow: -2px 0 #864, 0 2px #864, 2px 0 #864, 0 -2px #864;
}
h1 .second-half {
  color:#000;
  font-style: italic;
}
.container {
  margin-top:50px;
}
.form-container {
  border: 3px solid #864;
  border-radius:10px;
  background-color: #fff;
  padding:20px;
}

.sub-row {
  color:#333;
}
.sub-row .col {
  margin-top:50px;
}
.sub-row .col h4 {
  padding-bottom:3px;
  border-bottom:1px solid #864;
  margin-bottom:10px;
}
</style>

<meta charset="utf-8">
<!--

License, etc., info to come here soon.

-->
</head>

<!-- ########################################################################################## -->

<body>

<div class="container">

  <div class="row">
    <div class="col-md-8 col-md-offset-2">
      <h1>Warp<span class="second-half">Wallet</span></h1>
      <div class="form-container">
        <div class="form-group">
          <label for="passphrase">Passphrase</label>
          <input id="passphrase" class="form-control">
        </div>
        <div class="form-group">
          <label for="salt">Birthdate (YYYY-MM-DD)</label>
          <input id="salt" class="form-control">
        </div>
        <div class="form-group">
          <button class="btn btn-success" id="btn-submit">Generate / Lookup</button>
        </div>
        <div class="output-form" style="display:none;">
          <div class="progress">
          </div>
          <div class="form-group">
            <label for="public-address">Public Bitcoin Address</label>
            <input id="public-address" class="form-control">
          </div>
          <div class="form-group">
            <label for="private-key">Private Key (DO NOT SHARE)</label>
            <input id="private-key" class="form-control">
          </div>
        </div>
      </div>
    </div>
  </div><!-- /row -->

<!--
  <div class="row sub-row">
    <div class="col col-sm-4">
      <h4>What is WarpWallet?</h4>
    </div>
    <div class="col col-sm-4">
      <h4>Info</h4>
    </div>
    <div class="col col-sm-4">
      <h4>WarpWallet Challenge</h4>
    </div>
  </div>
  -->
</div>

</body>